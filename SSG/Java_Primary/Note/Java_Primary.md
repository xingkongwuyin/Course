# D1

1. java如果不配环境变量，只能在开发工具的目录下执行，想在所有的文件下执行，就需要配置环境变量
   
   > ![](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206181925386.png)

2. > 电脑上可以安装多个jdk，只能有一个jdk环境变量（path）。

3. > 编译文件也得转到要编译的目录下，因为java的开发工具可以全局使用了，但文件还是得在该目录下运行 

4. > 在一个源文件中可以声明class，但最多有一个public class,而且要求声明为public的类名要与文件名一致。
   >
   > 例：hello.java,该文件中的public class的类名应该是hello
   >
   > ```java
   > // hello.java
   > public class hello{
   > 	public static void main(String[ ]  args){  // args == arguments
   >        System.out.println("helloworld");
   > 	} 
   > }
   > ```

3. > 程序的入口是main方法，格式如上所示，是固定的
   >
   > * `public static void main(String[ ]  args)`

4. > 输出语句
   >
   > * System.out.println("hello");   先输出后换行  System.out.println();单纯起到换行的作用  
   > * System.out.print("hello");      只输出不换行

5. > * 编译过程：编译过后，会生成一个或多个字节码文件。字节码文件的文件名与Java源文件中的类名一致。
   > * java文件名要与公共类的类名一致，如果没有公共类，那么Java文件名字可以随意
   >
   > ![image-20220618101540049](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206181925404.png)
   
8. > ![image-20220618101840807](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206181925418.png)

9. > ![image-20220618141015456](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206181959807.png)

10. > * `long b1 = 199L` ，long整型在声明时，后面需要加L,系统缺省是int
    > * `float b2 = 0.2f` , 浮点型缺省是double

11. >  编码和解码都需要一套字符集。若要解码出来的一致，需要共用一套字符集
    >
    > 文本文档使是用UTF—8字符集编码的，而命令行窗口默认是GBK解码，所以会出现乱码的情况。即’中‘，在UTF—8的编码是1234，保存是按1234的二进制编码保存的，而cmd解码时，使用GBK解码，在GBK字符集中1234对应的字符或者不是’中‘，或者找不到，就会出现乱码的情况
    >
    > ![image-20220618145329305](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206182000388.png)

12. > 此时的容量大小是指，表示数的范围大小。比如：float的容量要比大于long的容量
    >
    > ![image-20220618161134817](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206182000407.png)

13. > * C可以发生截断，java不可以直接发生截断，直接会编译不通过，提示精度会有损失，C语言不管这个就直接放进去
    >
    > ![image-20220618162926265](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206182000439.png)
    >
    > ![image-20220618163121251](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206182003855.png)
    >
    > ![image-20220618163655366](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206182003180.png)
    >
    > * ==可以通过强制类型转换，将容量大的数据类型赋给容量小的数据类型==
    > * 在汇编中，整数字面常量是立即数的方式，即整数字面常量是是放在指令中的，当汇编时，是立即数的太大，是无法将整数所在指令，无法转成二进制指令所以就会报错
    >
    > ![image-20220618164857654](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206182000436.png)
    >
    > ![image-20220618165759594](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206182004710.png)
    >
    > ![image-20220618170133531](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206182004182.png)

14. > 

2. > ![image-20220618171535610](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206182000804.png)
   >
   > * 字符串是可以和8种数据类型做运算的,运算完后还是字符串类型
   >
   > * String类型变量的使用
   >
   >   + String属于引用数据类型，翻译为字符串
   >   + 声明String类型变量时，使用一对“”
   >   + String可以和8中数据类型变量做运算，且运算只能是连接运算：+
   >   + 运算的结果仍然是String类型
   >
   > * +号，当左右操作数都不是字符串类型，那么进行的是算术运算，否则是连接运算
   >

16. > ```java
    > char c = 'a'; // 97
    > int num = 10;
    > String s = "hello";
    > System.out.println(c + num + s); // 107hello
    > System.out.println(c + s + num);
    > System.out.println(c + (num + s));
    > System.out.println((c + num) + s);
    > System.out.println(str + num + s);
    > ```
    >
    >  
    >
    > ```java
    > System.out.printf('*' + ''\t'' + ' *' );
    > System.out.printf('*' + ('\t' + "*"));
    > // 二者的输出都是*  *
    > // 当其他数据类型和字符串类型发生运算时，其他数据里数据类型先转成字符串类型
    > ```
    >
    > 
    >
    > ```java
    > String s = "sgj";
    > int a = (int)String;
    > // byte、short、char --> int > long --> float --> double
    > // 上面是针对基本数据类型的算术运算，强制类型转换也是针对基本数据类型的
    > // 而String是引用数据类型，不能用与基本数据类型做算术运算，与基本数据类型做的
    > // 是连接
    > ```

# D2

1. > ![image-20220619163322865](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206191633920.png)

2. > 对于多个运算符在一起的表达式，从会变得角度我们也可以看出，一般指令有两个操作数，也就是说按照运算符的优先级，先运算哪两个操作数，将这两个操作数送到寄存器的时候，还要看是否两个操作数的类型需要转换，处理完这个运算符，再处理下一个运算符。类型转换，是发生在运算符的两个操作数之间，而不是一上来直接就把所有的数据转换容量最大的数据类型，什么时候用到这个运算符，什么时候考虑运算符两侧的操作数类型转换的事情
   >
   > ![image-20220619164946840](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206191649882.png)

3. > 取模返回值的正负和被模数一致
   >
   > ![image-20220619170023363](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206191700390.png)
   >
   > <img src="https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206191704729.png" alt="image-20220619170409699" style="zoom:200%;" />

4. > * ++,不会改变本身的数据类型，这是因为加1，1的数据类型和变量的数据类型一致
   >
   > ```java
   > short s1 = 10;
   > s1 = s1 + 1 // 错误
   > s1 = (short)(s1 + 1); // 正确
   > s1++;
   >     
   > ```
   >
   > * 如果整型字面常量的大小小于数据类型所能装的大小，那么也可以不用强转，但是字符型必须要后面加个f当是单精度时
   >
   >   ![image-20220619172004121](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206191720157.png)
   >
   >   
   >
   >   ```java
   >   byte b = 127;
   >   b1++ ;//结果是-128，因为自增加1，1的数据类型和b1的一致，所以导致了溢出
   >   ```

5. > ```java
   > // 连续赋值
   > int i ,j;
   > i = j = 10;   // (1)
   > int i = 10, j = 10;
   > 
   > ```
   >
   > ![image-20220619173040281](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206191730321.png)

6. > * +=等这些赋值运算符，不会改变数据类型。有以下两种情况
   >
   > ```java
   > short s = 10;
   > s = s + 10；// 错误
   > s += 10;    // 正确
   > 
   > 
   > // 1. 变量 
   > int a = 1000;
   > byte b = 0;
   > b += a;	
   > // 因为a的容量更大，所以b要先转，再与a进行运算，最后在强制类型转换成b的数据类型
   > 
   > // 2. 字面常量
   > short s = 10;
   > s += 10;
   > // s要先转成int,最后再转成short
   > 
   > 
   > // 总结
   >  s += a 
   > //虽然上面式子可以写成s = s + a，可是遵循的规则是，s和a转成容量更大数据类型，   最后的结果再强制类型转换成s的数据类型     
   > ```

7. > ```java
   > num++++;
   > (num++)++;  // 这两种方式都不可以
   > ```

8. > * 对于布尔类型，& | 是逻辑运算符，对于int等数据类型就是位运算符
   >
   > * 区分&和&&
   >
   >   * 相同点1：& 与 && 的运算结果一致
   >   * 相同点2：当符号左边是ture,二者都会进行符号右边的运算
   >   * 不同点：  当符号左边是false时，&执行左边的操作，而&&不会
   >
   >   ```java
   >   boolean b = false;
   >   int num = 10;
   >   // 1
   >   if(b1 & (num++))；
   >    System.out.println(num);  // num = 11
   >             
   >   // 2 
   >   if(b1 && (num++));
   >   System.out.println(num);  // num = 10
   >             
   >   // 这就是逻辑与和短路与的区别，短路与&&，当左边为假时，右边就不参与运算
   >   ```
   >
   > <img src="https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206191954576.png" alt="image-20220619195424544" style="zoom:200%;" />

9. > ![image-20220619195924387](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206191959419.png)
   >
   > ![image-20220619195720953](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206191957991.png)

10. > ![image-20220619202432539](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206192024586.png)

11. > * 一个workspace可以有多个project
    > * 一个project可以有多个包
    >
    > ![image-20220619221616471](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206192216504.png)

12. > * 按住ctrl键，同时鼠标指向类名，点击就可以看见源码
    >
    >   ![image-20220619222938578](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206192241192.png)
    >
    >   ![image-20220619223249095](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206192232121.png)

# D3

1. > ![image-20220620064640834](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206200646883.png)

2. > ```java
   > // 1. 
   > int num;   // 声明
   > num = 20;  // 初始化
   > 
   > // 2. 
   > int num = 10; // 声明 + 初始化
   > ```

3. > ```java
   > // 1. 一维数组的声明和初始化
   > 
   > // 1.1 静态初始化：数组的初始化和数组元素的赋值操作同时进行
   > int[] ids;      // 声明
   > ids = new int[]{1,2,3,4};
   > 
   > int[] ids = {1,2,3}; // 也是可以，这叫类型推断，前面的int[]不能省
   > 
   > // 1.2 动态初始化：数组的初始化和数组元素的赋值操作分开进行
   > String[] names = new String[3];  // 3是元素个数
   > 
   > // 错误写法
   > int[] arr1 = new int[];
   > int[5] arr2 = new int[];
   > int[] arr3 = new int[3]{12,2,3,4};
   > 
   > // 总结
   > // 数组一旦初始化，其长度就确定了		
   > ```
   >
   > ![image-20220620070435929](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206200704963.png)

4. > 数组的初始化
   >
   > * boolean 在内存中，false是用0充当，true是用1充当
   >
   > * null表示空值，没有数值
   >
   > * ```java
   >   boolean[] arr4 = new boolean[]{ture, false};
   >   // 这种方式也属于静态初始化，但是一开始初始化为false，后面用{true，false}
   >   // 给覆盖掉了
   >   ```
   >
   >   
   >
   > ![image-20220620072126965](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206200721001.png)
   >
   > ![image-20220620073321148](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206200733185.png)

5. > ![image-20220620073743757](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206200737797.png)

6. > 数组的内存解析
   >
   > ```java
   > int[] arr;
   > arr = new[]{1,2,3};
   > // 内存
   > // 先在栈区开辟一个arr的变量空间，后再堆区创建一个数组存放{1, 2, 3}
   > // 最后把堆区开辟数组的首元素的地址赋给arr
   > ```
   >
   > ![image-20220620074837100](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206200748130.png)

7. > * ctrl + d 选中后删除
   > * ctrl + shift + f 选中后调整

8. > 二维数组
   >
   > * ```java
   >   // 静态初始化
   >   int[][] arr = {{1,2,3},{13}};  // 自动类型推导
   >   ```
   >
   > * 二维数组可以看成是其元素是一维数组，所以其长度是一位数组的个数

9. > ![image-20220620082409497](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206200824540.png)
   >
   > ![image-20220620082551733](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206200825769.png)

10. > ![image-20220620132206793](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206201322852.png)

 # D4

1. > ![image-20220620192859886](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206201930862.png)

2. > 如果方法没有返回值，则方法声明时使用void来表示，没有返回值的方法，就不使用
   >
   > 返回值，如果使用return，只能用“return ；”，表示结束此方法。

3. > `ctrl + shift + h`,可以搜索类

4. > ==return关键字的使用==
   >
   > * 结束方法
   > * 针对于有返回值类型的方法，使用`return 数据`方法所要的数据
   >
   > ==注意==
   >
   > * return关键字后面不可以声明执行语句
   > * 方法的使用中，可以调用当前类的属性和方法。特殊的，方法A调用方法A,即递归方法（需要设计结束条件）

5. > ==理解万事万物皆对象==
   >
   > * 在java语言范畴中，将功能和结构等都封装到类中，通过类的实例化，来调用具体的功能结构，

6. > ==内存解析的说明==
   >
   > * 引用类型的变量，存在栈中，只能可能存储两类值：null、地址值（含变量的类型）

7. > ==匿名对象的使用==
   >
   > * 创建的对象，没有显示的赋给一个变量名，即匿名对象
   > * 匿名对象只能调用一次。
   > * 可以形参使用，即`mail(new phone())`,mai是个方法，形参类型是phone。
   >
   > ```java
   > class Person{
   >     int name;
   >     int age;
   > }
   > new Person().name; // 创建完直接调用
   > new Person().name; // 上下两个的对象不一致，因为每new一次，就创建一个对象
   >                    //  只不过这里创建的是匿名对象    
   > ```

8. > ==方法重载==
   >
   > * 定义：在同一个类中，允许一个以上的同名方法，只要它们的参数个数或者参数类型不同即可
   >
   >   两同：同一个类，相同方法名
   >
   > * 判断是否重载
   >
   >   跟方法的权限修饰符、返回值类型、形参类型名、方法体都没有关系
   >
   > ![image-20220620213437789](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206202134826.png)
   >
   > ![image-20220620213448856](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206202134884.png)

9. > ![image-20220620214853423](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206202148454.png)
   >
   > ![image-20220620215100107](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206202151183.png)
   >
   > ```java
   > show (String ... sts);
   > // 使用
   > show("aa", "bb");
   > show({"aa", "bb"});
   > // 把可变形参看作数组名就可以，遍历其中的元素时，和数组一致，都有
   > // strs.length strs[1]
   > ```

10. > ![image-20220620220016821](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206202200852.png)

11. > 
    >  * 类中属性的使用
    >  * 
    >  * 属性(成员变量) VS 局部变量
    >  * 
    >  * 1. 相同点：
    >  * 		1.1 定义变量的格式：数据类型 变量名 = 变量值 
    >  * 		1.2 先声明，后使用
    >  * 		1.3 变量都有其作用域
    >  * 
    >  * 
    >  * 2. 不同点
    >  * 		2.1 在类中声明的位置不同
    >  * 			属性：直接在类的一对{}内
    >  *          局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量
    >  *        
    >  *		2.2 关于权限修饰符的不同
    >  *			属性：          可以在声明其属性时，指明其权限，使用权限修饰符
    >  *			              常用的权限修饰符：private、public、缺省、protected
    >  *			局部变量：       不可以使用权限修饰符。但其所在的方法可以写，可以认为方法写了，
    >  *				          里面的局部变量跟方法的一致
    >  *		2.3	默认初始化值的情况:          
    >  * 		    类的属性：       根据其类型都有默认初始化值。跟之前的一致。
    >  * 						  整型(byte short int long) 0
    >  *                        浮点型(float double) 0.0
    >  *                        字符型(char): 0
    >  *                        布尔型(boolean): false
    >  *                        
    >  *                        引用数据类型(类、数组、接口、字符串): null
    >  *          局部变量：       无初始化值。意味着在调用局部变量之前，一定要显示赋值
    >  *                        特别地: 形参在调用时，再赋值即可
    >  *     2.4 在内存中加载的位置
    >  *         属性:           加载到堆空间(非static)
    >  * 局部变量:        加载到栈空间                        	

12. > * 一. Java面向对象学习的三条主线
    >  * 1. java类及类的成员，属性、方法、构造器（这三个最重要）；代码快和内部类
    >  * 
    >  * 2. 面向对象的三大特征：封装、继承、多态性  
    >  * 
    >  * 3. 关键字：this、super、static、final、interface、pakage、import等
    >  * 
    >  * 
    >  * 
    >  * 
    >  * leaning:
    >  * 1. 面向过程： 怎么做，强调做的过程
    >  * 2. 面向对象: 谁来做，把做的功能封装进对象，强调能实现该功能的人
    >  * 
    >  *  面向对象的两个要素
    >  *  1. 类：对一类事物的描述，是抽象的、概念上的定义。 可以理解成抽象概念上的人
    >  *  2. 对象：是实际存在的该类事物的每个个体，因而也被称为实例（instance）。 可以理解成实实在在的某个人
    >  *  3. 面向对象设计的重点是类的设计
    >  *  4. 设计类，就是设计类的成员
    >  *  
    >  *  注意：对象是实现功能的，得具有实现类中对象功能的功能，而类中的对象得具有功能来让类创建的对象实现。类中调用
    >  *      就是来实现类中对象功能，这也体现出类创建的对象有实现类内对象的功能的功能。例如，电话有打电话的功能
    >  *      而人有实现打电话的这个功能的功能，这个功能就是调用 

13. > * 一、设计类，就是设计类的成员
    >  * 
    >  *    Field = 属性 = 成员变量 = 域、字段
    >  *    Method = 方法 = 函数
    >  *    创建类的对象 = 类的实例化 = 实例化类
    >  *    
    >  * 二、类和对象的使用（类和对象思想的落地）
    >  *    1. 创建类、设计类的成员
    >  *    2. 创建类的对象
    >  *    3. 通过“对象.属性”或“对象.方法”，调用对象的结构   
    >  *    
    >  * 三、如果创建了一个类的多个对象，则每个对象都独立拥有一套类的属性（非static)
    >  * 	  意味着: 如果我们修改一个对象的属性a,则不影响另外一个对象a的属性值

14. > 当一个类中有多个方法时，调用这些方法时，会为这些方法单独开辟一些内存空间

 # D5

1. > ==封装性的体现==
   >
   > * 我们将类的属性xxx私有化（private），用时向外提供公共的（public）方法来获取
   >
   >   （getxxx），和设置（setxxx）
   >
   > * 不对外暴露的私有（private）方法，即类内的方法只允许类内使用
   > * 类内的属性不管是何种权限，都可以被同一类内的方法调用，也不管这个方法的权限如何，即同一类内的方法调用属性，不考虑权限的事，权限是对外来说的

2. > ==封装性的体现需要权限修饰符来配合==
   >
   > * 4种权限可以用来修饰类及类内的结构：属性、方法、构造器、内部类
   >
   > * 具体的，4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类
   >
   >   ​                 修饰类的话，只能用：缺省、public

3. > 总结==封装性==
   >
   > * Java提供了四种权限修饰符，来修饰类的内部结构，体现类及类的内部结构在被调用时的可见性的大小。
   >
   >   ![image-20220621065749740](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206210741805.png)

4. > ==构造器==
   >
   > * 创建类的对象 = new + 构造器
   > * 构造器的权限和该类的权限一致，如果这个类是public，那么它的构造器也是public
   > * 如果没有显示的定义类的构造器，则系统默认提供一个空参的的构造器
   > * 定义构造器的格式：`权限修饰符 类名（形参列表）{}`
   >   * 与类同名，且在类中定义
   >   * 一个类中定义的多个构造器，彼此构成重载
   >   * 创建对象时，同时初始化
   >   * 一旦显式的定义了构造器之后，系统就不提供默认的空参构造器。那么如果类中没有空参构造器，但有其他构造器，类外又用空参构造器就会报错
   >   * 一个类中只有有一个构造器，要么自己写，要么系统提供
   >
   > ```java
   > Person p = new Person();   // Person()就是构造器
   > ```

5. > ==属性赋值==
   >
   > * 默认初始化
   > * 显式初始化      
   > * 构造器中初始化   
   > * 通过“对象.方法”或“对象.属性”的方式，赋值  

6. > ==this关键字的使用==
   >
   > * this可以用来修饰：属性、方法、构造器
   >
   >   this修饰属性和方法，this可以理解成：当前对象或当前正在创建的对象
   >
   >   + >  在==类的方法==中，我们可以使用“this.属性”或“this.方法”的方式，调用
   >     >
   >     > 当前属性和方法。但是，通常情况下，选择省略“this.”，特殊情况下,
   >     >
   >     > 如果方法的形参和类的属性同名时，我们必须显示的使用“this.变量",方式，来表示此变量是属性，而不是形参   
   >
   >   + > 在==类的构造器==中，我们可以使用“this.属性”或“this.方法”的方式，调用
   >     >
   >     > 当前正在创建的对象属性和方法。但是，通常情况下，选择省略“this.”，特殊情况下，如果构造器的形参和类的属性同名时，我们必须显示的使用“thi变量方式，来表示此变量是属性，而不是形参
   >
   > * this 调用构造器
   >
   >   + >  我们在类的构造器中，可以显示的使用“this（形参列表）”方式，调用本类中指定的类的其他构造器（重载的构造器）。
   >
   >   + > 构造器不能通过“this（形参列表）”方式调用自己。 
   >
   >   + > 如果一个类中有n个构造器,则最多有`n-1`构造器使用"使用this(形参列表)"
   >
   >   + > 规定: "this(形参列表)"必须声明在当前构造器的首行
   >
   >   + > 构造器内部,最多之只能声明一个"this(形参列表)",用来调用其他的构造器
   >
   > ![image-20220621121042180](https://dawn1314.oss-cn-beijing.aliyuncs.com/202206211210229.png)
   >
   > ![image-20220621092416703](https://dawn1314.oss-cn-beijing.aliyuncs.com/202206210924756.png)
   >
   > ![image-20220621115938001](https://dawn1314.oss-cn-beijing.aliyuncs.com/202206211159042.png)
   >
   > ![image-20220621091020040](https://dawn1314.oss-cn-beijing.aliyuncs.com/202206210910126.png)

7. > ==what(这个东西是什么)？ why（为什么要用这个东西）？ how（怎么用这个东西）？学习一个只是可以从这三点入手==

8. > `ctrl + shift + H`,在其他类中可以使用此快捷键,搜索其他的类.
   >
   > `crtl + f`在本类中查找某个信息

9. > package 关键字的使用
   >
   > * 包.为了更好的实现项目中类的管理,提供包的概念
   >
   > * 使用package声明类或接口所属的包,声明源文件的首行
   >
   > * 包,属于表示符,遵循标识符的命名规则,规范(xxxyyyzzz),"见名知意"
   >
   > * 每"."一次代表一层文件目录
   >
   >   同一包下不可以命名同名的接口,类(class不管前面是否有public,都不能,重名,一个类,只能声明一次)
   >
   >   ![image-20220621131500664](https://dawn1314.oss-cn-beijing.aliyuncs.com/202206211315724.png)

10. > ==import关键字的使用.    导入==
    >
    > * 在源文件中显示的使用import结构导入包下的类和接口
    >
    > * 声明在包的声明和类的声明之间 
    >
    > * 如果需要导入多个结构,则并列写出即可
    >
    > * 可以使用"xxx.*"的方式,表示可以导入xxx包下的所有结构.
    >
    > * 如果使用的类或或接口是java.lang包下定义的,则可以省略导入,默认已经导入,直接用即可
    >
    > * 如果使用的类或接口是本包下定义的,则可以省略import结构
    >
    > * 如果在源文件中,使用了不同包下的同名的类,则必须有一个类,需要以全类名方式显示
    >
    >   ![image-20220621142327985](https://dawn1314.oss-cn-beijing.aliyuncs.com/202206211423037.png)
    >
    > * 使用"xxx.*"方式表示可以调用xxx包下的所有结构.但是如果使用的是xxx
    >
    >   子包下的结构,则仍需要显示导入
    >
    > * `import static`:导入指定类或接口中的静态结构:属性或者方法
    >
    >   <img src="https://dawn1314.oss-cn-beijing.aliyuncs.com/202206211440004.png" alt="image-20220621144013970" style="zoom:200%;" />
    >
    > ![image-20220621144122895](https://dawn1314.oss-cn-beijing.aliyuncs.com/202206211441941.png)

11. > `crtl + shift + h`在层次结构中打开class,`crtl + shift + T`,直接打开

12. > ==eclipse常用快捷键==
    >
    > <img src="https://dawn1314.oss-cn-beijing.aliyuncs.com/202206211443874.png" alt="image-20220621144335815" style="zoom:200%;" />
    >
    > <img src="https://dawn1314.oss-cn-beijing.aliyuncs.com/202206211453731.png" alt="image-20220621145349679" style="zoom:200%;" />
    >
    > <img src="https://dawn1314.oss-cn-beijing.aliyuncs.com/202206211457763.png" alt="image-20220621145700717" style="zoom:200%;" />

13. > ==面向对象的特征之二,继承性==
    >
    > 一. 继承的好处
    >
    > * 减少了代码的冗余,提高了代码的复用性
    > * 便于功能的扩展
    > * 为之后多态性的使用,提供了前提
    >
    > 二. 继承性的格式
    >
    > * class A extends B{}
    >
    >   + A:  子类,派生类,subclass
    >
    >   + B:  父类,超类,基类,superclass
    >
    >   + 体现: 一旦子类继承父类B以后,子类A中就获取了父类B中声明
    >
    >     ​           的结构: 属性,方法.   特别的,父类中声明为private的属性或方法,
    >
    >     ​            子类继承父类之后,仍然认为获取了,父类中私有的结构,只是因为
    >
    >     ​             封装性的影响,使得子类不能直接调用父类的结构而已.
    >
    >     ​    
    >
    >     ​             子类继承父之后,还可以声明自己特有的属性和方法:实现功能
    >
    >     ​             的扩展. 子类和父类的关系: 不同于子集和集合的关系
    >
    >      
    >
    >                  extends: 扩展 延展
    >
    > 三.  java中关于继承的规定
    >
    > * 一个类可以被多个子类继承
    > * java的单继承性：一个类只能有一个父类（C++可以多继承）
    > * 子父类是相对的概念
    > * 子类直接继承的类是直接父类，间接继承的父类为简介父类
    > * 子类继承父类之后，就获取了直接父类以及所有间接父类中的声明的属性和方法
    >
    > 四、
    >
    > * 如果我们没有显式的声明一个类的父亲的话，则此类继承于java.object.lang类，即可以使用xxx.yyy,yyy是父类中的方法
    > * 所有的类（java.lang.Object）都直接或间接继承于java.lang.Object类
    > * 意味着，所有的java类具有java.lang.Object类声明的功能
    >
    > 
    >
    > 
    >
    > ![image-20220621154135321](https://dawn1314.oss-cn-beijing.aliyuncs.com/202206211541387.png)
    >
    > ![image-20220621154920768](https://dawn1314.oss-cn-beijing.aliyuncs.com/202206211549807.png)
    >
    > ​                           

14. >  ==Debug调试==
    >
    > ![image-20220621161047205](https://dawn1314.oss-cn-beijing.aliyuncs.com/202206211610254.png)

15. > ==方法的重写==
    >
    > * （1）重写：子类继承父类之后，可以对父类中同名同参数的方法，进行覆
    >
    >   ​                       盖操作     
    >
    >    （2）应用： 重写之后，当创建类对象之后，通过子类对象调用父类中的同
    >
    >   ​                        同参数的方法时，实际执行的子类重写父类的方法。即父类中
    >
    >   ​                        有个方法，在子类中，重写写个方法，方法名，和参数都一致
    >
    >   ​                        这时就是实现了重写的操作
    >
    >     （3）重写的规定：  
    >
    >   + 方法的声明： 权限修饰符  返回值类型 方法名（形参列表）{方法体}
    >
    >     ​                        约定俗成：子类中的叫重写的方法，父类中的叫被重写
    >
    >     ​                                             方法
    >
    >   + 子类重写的方法的方法名和形参列表与父类被重写的方法名和形参列表相同
    >
    >   + 子类中不能重写父类中不能重写父类中声明为private的方法。即子类中可以有和父类中同名同参的但修饰符为private的方法。
    >
    >   + 返回值类型
    >
    >     (1)父类被重写的方法的返回值类型是void，则子类重写的方法的返回值只能是void
    >
    >     (2)父类被重写的返回值类型是A类型，则子类重写的返回值类型可以是A类，也可以是A的子类
    >
    >     (3)父亲被重写的方法的返回值类型是基本数据类型，则子类重写的方法的返回值类型，必须是相同的数据类型
    >
    >     (4)子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常
    >
    >     (5)子类中同名同参数要么都声明为非static的（考虑重写），要么都声明为static的（不是重写，因为static的方法一定是不可以被重写的）

16. >  ==super关键字的使用==
    >
    > （1）super理解为：父类的
    >
    > （2）super可以用来调用：属性、方法、构造器
    >
    > （3）super的使用
    >
    > + 可以在子类的方法或构造器中，通过使用“super.属性”或“super.方法”的方式，显示的调用，父类中声明的属性或方法。但是，我们通常情况，我们习惯省略“super.”。也就是说，当在子类中调用某个属性时，先在子类中找，如果找不到，再去父类中找，这个父类不一定是直接父类，直接父类找不到，就去间接父类去找。
    >
    > + ==属性==      特殊情况，当子类和父类中定义了同名的属性时，想在子类调用父类中声明的属性，则必须显式的使用“super.属性”方式，表明调用的是父类中的属性。属性是不存在覆盖之说的。
    >
    > + ==方法==       当子类重写了父类中的方法后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用“super.方法”的方式，表明调用的是父类被重写的方法。
    >
    > + ==构造器==    
    >
    >   + 我们可以在子类构造器中显示的使用“super（形参列表）”的方式，调用父类中声明的指定构造器（通过形参列表来看）
    >   + “super（形参列表）”的使用，必须声明在子类构造器的首行。
    >   + 在类的构造器中，针对于”this（形参列表）“或“super（形参列表）”只能二选一，不能同时出现
    >   + 在构造器的首行，没有显式的声明“this（形参列表）”或“super（形参列表）”，则默认调用的式父类中的空参的构造器“super（形参列表）”
    >   + 在类的多个构造器中，至少有一个构造器中使用了“super(形参列表)”，调用父类中的构造器。
    >
    >   <img src="https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206212044282.png" alt="image-20220621204447238" style="zoom:200%;" />
    >
    >   <img src="https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206212106172.png" alt="image-20220621210622128" style="zoom:200%;" />

17. > ==子类对象实例化的过程==
    >
    > + 从结果来看（继承性）：   
    >   + 子类继承父类以后，救获取了父类中声明的属性或方法，创建子类对象，在堆空间中，就会加载所有父类中声明的属性，也就是创建的内存中有了所有父类的属性，==这里没有父类中的方法怎么去加载，后面的学习关注一下==
    >
    > + 从过程来看;
    >
    >   + 当我们通过子类的构造器创建子类对象时，我们一定直接或间接的调用父类的构造器，进而调用父类的父类的构造器，直到调用了java.lang.object类中空参的构造器为止。正因为加载过所有父类的结构，所以才剋看到内存中有父类的结构，子类的对象才可以考虑进行调用。
    >
    > + 明确：
    >
    >   虽然创建子类对象时，调用了父类的构造器，但是自始自终，就创建过一个对象，即为new的子类对象。也就是说，对象是否创建，关键看new
    >
    >   <img src="https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206212119178.png" alt="image-20220621211931139" style="zoom:200%;" />                               

18. > ==面向对象的特征之三：多态性== 
    >
    > * 理解多态性：可以理解为一个事物的多种形态。
    >
    > * 何为多态性
    >
    >   + 对象的多态性：父类的引用指向子类的对象（或者叫子类的对象赋给父类的引用）。    
    >
    >   + 多态的使用：
    >
    >     （1）当调用子父类同名参数的方法时，实际执行的是子类重写父类的方法（虚拟方法调用）
    >
    >   ```java
    >    Person p1 = new man();   //   man是Person的子类   左边是父类的声明，
    >                             //                      右边是子类的对象
    >    Person p1 = new woman(); //   woman是Person的子类
    >   ```
    >
    > * 多态的使用：虚拟方法的调用
    >
    >   + 有了对象的多态性后，我么在编译期，只能调用父类声明的结构，但在运行期，我们实际执行的是子类重写父类的方法。编译看左边，运行看右边
    >
    > * 多态性的使用前提：
    >
    >   + 类的继承关系
    >   + 要有方法的重写
    >
    > * 对象的多态性，只是用方法，不适用于属性。编译和玉兴都看左边。当创建父类对象指向子类时，在内存空间，属性是加载了子类和父类所有的属性，包括重名的（父类的属性不被覆盖），而方法，只有重写的==方法是否只有重写的，我不确定，是否还有父类没有被重写的==。多态是运行时的行为，不是编译时的行为。
    >
    >   
    >
    >   ![image-20220621214201090](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206212142127.png)
    >
    >   
    >
    >   ![image-20220621215152270](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206212151302.png)
    >
    >   
    >
    >   
    >
    >   ![image-20220621215308369](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206212153404.png)
    >
    >   
    >
    >   ![image-20220621220856847](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206212208884.png)
    >
    >   
    >
    >   
    >
    >   ![image-20220621215518235](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206212155272.png)
    >
    >   
    >
    >   
    >
    >   ![image-20220621215656628](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206212156660.png)
    >
    > 
