* if(); 最后面这个；，代表if这个选择语句就已经结束，下面的else就没有相应的if与之匹配

  ![image-20220422203751770](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202204222037791.png)

  

* 应该是tmp*（）；不然成函数调用了。==不要字面数学表达运用在代码上面==

![image-20220422203741789](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202204222037804.png)

* > 虽然a是个浮点数，但除了a之外那几个数都是整数，还是会按整数的除法，最后得出0的答案
  >
  > ![image-20220422203726737](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202204222037771.png)
  >
  > 正确：任意一个数变成浮点数即可
  >
  > ![image-20220422203712056](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202204222037079.png)

* > scanf连续读取字符时一定要把字符回车字符拿走！
  >
  > ![image-20220422203701157](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202204222037188.png)
  >
  > ![image-20220422203648404](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205030722002.png)



* `scanf("%d  %c",&a,&c)`,对于scanf连续读取，中间有空格（相当于空白字符，多个空格相当于一个），那么在输入时，就得添加空白字符，或者敲回车，回车也是空白字符，

* 

  ><img src="https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202204222035574.png" alt="image-20220422203555544"  />





* >以后浮点数尽量用double，毕竟系统默认浮点数的数据类型是double
  >
  >![image-20220422202936023](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202204222029082.png)
  >
  >![image-20220422203058341](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202204222030378.png)





* >在连续写判断条件时，千万别像下面这样写
  >
  >![image-20220425195320693](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202204251953723.png)

* > ![image-20220504225544687](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205061345287.png)

* > ![image-20220504183902112](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205061345337.png)

* > ![image-20220508220116570](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205082201674.png)

* > * if判断，当第一个（）里的条件判断为真时，就不会往下判断
  >
  > 这也是没有得到正确答案的原因
  >
  > * 启发：正对角线时i=j,负对角线是i+j=n(n为矩阵的阶数)
  >
  > ![image-20220510203220880](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205102032957.png)
  >
  > ![image-20220510203234547](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205102057404.png)



* > ![image-20220510204519777](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205102057777.png)
  >
  > ![image-20220510204543791](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205102057489.png)

* > 可以通过for循环中的循环变量来判段，循环的次数和循环是否结束
  >
  > ```C
  > for(int i=0;i<5;i++);//(空实现)
  > // 只有当i>=5,时，才可能结束循环，但凡i在满足条件都会进行循环（排除中止情况），
  > // 这个隐藏信息不光在for循环，在while循环也比较常用，因为循环完后，我们要看是否循环完毕，来进行下一步的操作
  > ```
  >
  > 

* > ![image-20220512215925842](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205122159891.png)

* > * 首先在栈区创建的是i这个变量，然后是数组，所占内存空间分布如下。代码中，arr[12],等同于*（arr+12）,正好解引用的是i的空间，当循环到i=12时，arr[12]又把i变成了0，所以会造成死循环，但这种情况比较巧，有的编译器会正好分配空间，有的不会。
  > * 在Vs2019上我尝试了一下，同时创建两个变量的内存空间的地址之差为12，即`int i = 0;int ii = 0;`,而上一个代码中的整型变量和数组元素最后一个地址相差2，这可能于内存对齐有关
  >
  > ```C
  > #define  _CRT_SECURE_NO_WARNINGS	
  > #include <stdio.h>
  > int main()
  > {
  > 	int i = 0;
  > 	int arr[10] = { 0 };
  > 
  > 	for (i = 0; i <= 12; i++)
  > 	{
  > 
  > 		arr[i] = 0;
  > 		printf("hehe");
  > 
  > 	}
  > 
  > 	return 0;
  > }
  > ```
  > ![image-20220517200743727](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205172008744.png)



* > ![image-20220517204532611](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205172045687.png)

* > ![image-20220517204441158](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205172045784.png)

* > 数组名是个指针常量,不可修改,但指向的值可以修改
  >
  > ![image-20220517212637423](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205172126473.png)

* > ![image-20220521061829679](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205210618737.png)
  >
  > ![image-20220521061853080](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205210618167.png)

* > ![image-20220521062132917](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205210621992.png)
  >
  > ![image-20220521062250443](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205210622515.png)

* > *  C语言的基本组成单位是函数
  >
  > * 输入/输出函数是标准库函数，而标准库函数是厂商提高效率创造的
  >
  > * ```C
  >   int a = 0;
  >   int b = 0;
  >   char c = 0;
  >   double d = 0;
  >   a * b + d - c;
  >   // a * b先执行的是int型整数的除法，操作完之后，再隐式转换成double类型
  >                 
  >   ```

* > ![image-20220522092512839](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205220925866.png)

## Visual studio代码旁边这种黄色和绿色的条状线  

![image-20220404175011536](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205222123723.png) 

> char a a里面是字符，不是地址
>
> ```
> 指针做偏移操作的时候是根据指针的类型来做出移位判断，比如这个例子里面指针是整形，所以每次偏移的时候是按照整形的长度（4字节，32位）偏移，如果指针是char类型，则每次加1是加1个字节
> 指针自增每次增加的增加量=sizof（你所用的数据类型）
> 比如
> char型指针 自增的话地址加1
> int型 一般都是4字节，所以自增会加4.
> ```

## C语言中常量的类型

> C语言中的常量一般分为两类整型常量和浮点数常量。
>
> 整型常量的默认数据类型是int类型，即有符号整型。
>
> 浮点数常量的默认类型是double类型，即长浮点数类型。
>
> 注意：整型常量中有一类特殊的常量，即字符常量，有字符常量，引申出字符串常量。字符常量的默认类型是char类型，即有符号字符类型，字符串常量的类型，一般为const int类型。同时，不同的编译器，略有不同，但一般遵守该规则。

## 指针

> * int num=10；int申请空间，num，是申请得到空间的名字，10，这个空间放10
>   *    每一个内存单元，都有地址，这是提前分配好的，地址也叫做指针，而指针变量是把地址存进去（指针变量先申请空间，而这个空间用来存放地址）
>
> * &a、&b分别表示变量a和变量b的地址。
>   * 这个地址就是编译系统在内存中给a、b变量分配的地址。在C语言中，使用了地址这个概念，这是与其它语言不同的。 应该把变量的值和变量的地址这两个不同的概念区别开来。变量的地址是C编译系统分配的，用户不必关心具体的地址是多少。

## double 和float

> 浮点常数通常以 double 类型存储在内存中。如果需要强制将这类常数存储为 float 类型，则可以将 F 或 f 字母附加到其末尾。例如，以下常数将被==强制==存储为 float 类型数字：
>
> 1.2F
> 45.907f
>
> 注意，由于浮点常数通常是以 double 类型存储在内存中的，所以，在为 float 变量分配一个浮点常数时，某些编译器会发出警告消息。例如，如果 num 是一个 float 类型的变量，则以下语句可能会导致编译器生成警告消息：
>
> num = 14.725;
>
> 在这种情况下，可以通过在浮点常数后面附加f后缀来抑制错误消息，如下所示：
>
> num = 14.725f;
>
> 如果要强制将某个值存储为 long double，则可以给它附加一个 L 后缀，如下所示：
>
> 1034.56L
>
> 由于小数点的存在，编译器并不会将它与长整型混淆。也可以使用小写字母l来将浮点常数定义为 long double，但是最好能使用大写字母 L，因为小写字母 l 容易与数字 1 混淆



 ## scanf

* 在程序开始运行的时候，标准输入流中的字符串为 `"HelloWorld!"` ，`scanf` 首先尝试匹配 `'%c'` ：

```
HelloWorld!
^
```

` '%c'` 匹配了指针指向的字符 `'H'` ，指针后移一位，长度达到限制， `'%c'` 停止匹配。

```
HelloWorld!
 ^
```

*  此时 `scanf` 尝试匹配 `'%s'` ， `'%s'` 的匹配规则为：匹配连续字符，直到遇到空白符（空格、换行或者格式制表符等）。 `'%s'` 成功匹配该行剩下的所有字符 `"elloWorld!"` ，并将其存到字符数组 `str` 中。

```
scanf("%c%4s",&ch,&str); // c前面就只能是1，s前面可以指定数值
```

* 格式说明符和格式字符串
  * scanf（“%d%d”，&a，&b）“%d%d”：格式字符串 %d格式说明符
  
* `sizeof(arr) /sizeof(arr[0])-1`，是求arr最大下标

* 浮点数强转为整形数，规则是直接舍去小数部分，就没有四舍五入。

  ![image-20220420200253451](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205222123918.png)

  

* > 三目操作符，适合条件赋值，不适合两个数转换。
  >
  > ![image-20220420220745681](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205222123728.png)

* %10，会出个一位数，%100，会出个两位数

  ```C
  25%10=5
  125%100=25
  1234%1000=234
  // 也可以看出，%10 %100 1后面有几个0，就会模下几个数
  ```

  ## C语言中scanf()函数的返回值

* ~2是按位取反，不是逻辑取反，逻辑取反是！

* > 返回0，是因为要求输入一个数字，却数输了一个字符
  >
  > 也就是说，`while（~scanf（“%d”，&a））`,只能输入数字，输入字符则进入下次循环
  >
  > ![image-20220422204054222](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205222123922.png)



* > scanf("%d",&a),遇到空白字符就停止
  >
  > scanf（"%c",&a）,就不是遇到空白字符 就停止了，遇到什么字符就读什么字符，遇到\n,就读\n,连续读字符时，需要用getchar（），及时拿走不想要的字符

* > % 适用于整数，不适用浮点数 

* > ![image-20220422231630290](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205222123845.png)



* > 如果初始化时的数据类型与下面的scanf读取时的格式符不一致，就会出错
  >
  > ![image-20220422232857927](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205222123848.png)



* > ![image-20220426102537255](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205222123247.png)
  >
  > ![image-20220426102625927](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205222123343.png)
  >
  > ==注：-2d应该是左对齐==
  
* > (v1,v2)是逗号表达式，最终会从左到右算出一个值，例如（v1，v2）算出的就是v2的值

* >在创建字符串时，默认是以”\0结尾的，如果创建数组的大小放不下”\0“,打印时找不到”\0“,就会一直打印下去，直至找到"\0",这样就会造成数组越界![image-20220426105511997](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205222123441.png)

* >
  >
  >![image-20220426201853774](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205222123347.png)

* > 
  >
  > ![image-20220426203537974](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205222123362.png)

* > 对于汉诺塔递推公式F（n），表示的意思是，借助某一根柱子到达另一根柱子的方法有多少
  >
  > 对于抖m这个题，F（n）得是借助某一根柱子到达另一根柱子的方法有多少
  >
  > ==由此可见，对于递推公式所表示的含义必须清楚==
  >
  > ![image-20220503211142188](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205222123340.png)
  >
  > ![image-20220503211216260](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205222123813.png)

* > 求素数，用到sqrt求平方根，不能用小于，因为sqrt返回的是浮点数，但相比的是整型，所以会强制转换成整型，全部舍掉小数后的位数，例如求4是否为质数，用这个代码就输出不了
  >
  > ![image-20220503220908825](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205222123733.png)

* > 判断条件有两种写法
  >
  > * 第一：根据循环的次数，来定判断条件，但这结合初识条件
  > * 第二：==根据已知条件来写，有时这个已知条件，题中并没有明显给出来，这时候需要自己去想一下，即构造一个已知条件==
  >
  > 在递归中，最下面的方框一般的写法是，将2中的条件带入1中，得到3.这就是根据已知条件来写判断条件下的代码
  >
  > ![image-20220503232840526](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205222123792.png)

  
  
  
  
* > 下述方法提供一种结束循环的一种方法
  >
  > ![image-20220506070759717](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205222123806.png)

* 电脑快捷键
  * shift + enter 可以使光标垂直向下移动
  * 在中文模式下 shift+6的结果是......  shift+ -是——

* > * 空指针不能解引用,即char* p=NULL;*p是不允许的
  >
  > * 在字符串中,最后一个字符是\0,在内存空间对应的整型是0,所以对该字符串解引用时,得出的数值是0.

* > `while(scanf( " %c",&ch)==1)`
  >
  > * %c前面加空格，跳过下一个字符前的所有空白字符，即%c前面有一空格，则搭配输入缓冲区的下一个字符前的所有空白字符
  >
  > * scanf和wscanf都返回成功转换和分配的字段数；返回值不包括已读但未分配的字段。返回值为0表示没有字段被分配。如果出现错误，或者在第一次尝试读取字符时遇到文件结束符或字符串结束符，则返回值为EOF
  >
  >   * %d，却输入字符，返回0；%s，输入后返回1，不是返回字符的个数，是返回被分配的字段数
  >
  >   <img src="https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205222123821.png" alt="image-20220520123900666" style="zoom: 150%;" />
  >
  >   <img src="https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205222123889.png" alt="image-20220520123907558" style="zoom:150%;" />
  >
  >   ![image-20220520124045313](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205222123093.png)

* > x,y的最小公倍数是x*y/（x和y的最小公约数）。最小公约数可以根据辗转相除法得到

![image-20220526222955634](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205262229666.png)

* typedef重定义数据类型

  <img src="https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206040929870.png" alt="image-20220604092900823" style="zoom:150%;" />

  ![](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206040931332.png)

* 当用malloc分配的空间，中间不一定存的是0

* 当声明变量时，其格式是：数据类型 变量名称

* > 反证法
  >
  > * 用于条件
  >
  > ![image-20220605215642904](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206052156935.png)
  >
  > * 用于单个论题（见下文）
  >
  > 归谬法（见下文）
  >
  > > 反证法与归谬法极其相似，但是却有本质区别，下面以两个例子来说明这个区别
  > >
  > > 反证法的例子：
  > >
  > > 楚庄王养的一匹爱马死了，他十分痛心，命令群臣用大夫等级的礼节来埋葬这匹马。大臣们说不能这样做。楚庄王非常生气，下令：“有敢以马谏者，罪致死。”优孟听说此事后，去见楚庄王。要求以君王之礼来葬这匹马，并叫上各诸侯国，以便好让各诸侯都知道大王贱人而贵马的事。楚庄王听了，羞愧满面，如梦初醒。
  > >
  > > 优孟谏楚庄王所用的就是反证法。他意欲向楚庄王论证论题：“不该用重礼葬马”。为了论证这个论题，他先提出一个反论题：“该用重礼葬马”。从这一反论题引出的判断是：各诸侯都知道“大王贱人而贵马”。而这种结果对楚庄王来说是十分危险的，所以这个反论题为假。既然“该用重礼葬马为假”，那么“不该用重礼葬马”就为真的了。
  > >
  > >  
  > >
  > > 反证法步骤：要证明P是真的
  > >
  > > 首先假设P是假的，也即非P，推导出了Q，然而事实是非Q，根据矛盾律，Q和非Q不能同时成立，因此假言推理的后件为假，而假言推理又是真的，所以前件就是假的，也就是说非P是假的，因此P就是真的（注意到这里用到了双重否定律，事实上只有承认了排中律之后才能有反证法，也就是说P和非P一定有一个是真的）
  > >
  > >  
  > >
  > > 在进行反证中，只有与论题相矛盾的命题才能作为反论题，论题的反对命题是不能作为反论题的。（事实上这里说的就是排中律）为了使论题的真实性得到论证，重要的一环是确定反论题的虚假。为此通常采用归谬法。
  > >
  > >  
  > >
  > > 归谬法的例子：
  > >
  > > 据冯梦龙《古今笑史·塞语部》记载：东汉南昌人徐孺子十一岁的时候，有一次同太原人郭林宗出游，游毕回到郭家时，因郭宅庭中有一树，郭欲将树伐去。郭伐树的理由是：“为宅之法，正如方口，口中有木，困字不详。”徐孺子对此进行了反驳。如果宅中有树，有不详的“困”字，就要把树砍去的话，那么“为宅之法，正如方口，口中有人，囚字何殊？” 意思是：如果因“困”字不祥要砍树，岂不是要因为“囚”字不祥而把家中人杀掉吗？
  > >
  > > 徐孺子对郭林宗砍树理由的反驳不是通过正面说理来进行，也不是以事实来说服郭林宗，而是顺着郭林宗的思路，以郭林宗的逻辑引出荒谬，说服郭林宗不要砍树。这个反驳就是一个归谬反驳的过程，运用的是逻辑上的归谬反驳法。
  > >
  > >  
  > >
  > > 归谬法步骤：要证明P是假的
  > >
  > > 首先假设P是真的，因此推导出了Q，然而事实却是非Q，根据矛盾律，Q和非Q不能同时成立，因此假言推理的后件为假，而假言推理又是真的，所以前件就是假的，也就是说P是假的。（注意到这里并不需要用到排中律）
  > >
  > >  
  > >
  > > 从上面的论证中可以看到，反证法和归谬法是不一样的论证方法，反证法是用来证明一个结论的，而归谬法是用来反驳一个结论的。这两种方法都用到了矛盾律，但是反证法还用到了排中律。

* > ==2 ^ 5==是2异或5，不是2的5次方

* > ![image-20220611074117183](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206110741229.png)

* > ![image-20220611215624919](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206112156947.png)

* 
* 
