

## 1.什么是C语言

1.1 二进制指令—>汇编语言（一些助记符，例如英文字母）—>高级语言

1.2 编译器，编辑和翻译。编辑，即对代码进行剪切、复制一些文本操作；翻译，将代码翻译（变成计算机能够识别的语言，还需要链接器）

## 2.第一个C语言程序

2.1 函数分为两部分，函数头和函数体。函数头又由声明、函数名和输入参数组成。int 声明函数返回类型，同时申请int类型数据所占空间大小（int，4个字节）；函数名，整个项目只能有一个main函数，而且整个项目的代码都是从main函数开始；输入参数，一开始也是要先声明。

2.2 main()里面无参数（或者由viod），这表示不用输入参数。如果有的函数名前面有viod，表示可以不用有输出

2.3 stdio.h 为标准输入输出库文件。std：standard；i：input；o:output. 使用scanf（输入函数）也需要引此文件

```c
#include <stdio.h>
int main()   
{
    printf("hello")
    return 0;
}
```

## 3.数据类型

3.1 C语言中没有字符串类型。字符串，也就是由单个字符组成。这matlab不一样，matlab中字符串是作为一个整体存在，而字符组成的叫做字符数组

3.2 计算机存储字符是以ASCiLL码存储的

## 4.变量和常量

4.1 定义变量。定义变量的第一步就是先定义变量，即申请空间，而这个空间的名字就是变量名。“=”后面是常量，即把常量存储在名叫变量名的空间中。在C语言中，使用变量的第一步就是先声明变量（也是说先申请空间）。定义变量的同时也初始化了变量，如果指定一个值，那就是把指定的值存储进去，如果定义时不指定，系统会随机指定一个值放进去,不是放0进去。

```C
int a=0;
```

4.2 在同一个{}中，同一个变量不能重定义，即变量名不能被定义两次，即使是被不同数据类型所定义。

```C
// 这不算在同一{}中
{
    int a=0;
    {int a=1;} //这有点类似全局变量和局部变量的关系
}
// 重定义
{
    int a=0;
    char a='e'; //这也算重定义
}
```

4.3

- 局部变量：{}内部所定义。
- 全局变量：所有的{}外部所定义。全局变量，一个源文件定义后，可以在同一项目的其他的源文件使用，但需要先声明

```c
test1.c
int a=0;
{
}
test2.c 
extern int a //后面的数据类型和变量必须和全部变量被声明保持一致
```

4.4 变量名是个标识符，但有时可以表示地址。scanf和printf函数，会在缓存区读取数据。

- int a 变量a就是个标识符。
- char a[] 变量a可以表示地址。

4.5

- 全局变量的作用域是整个项目，而生命周期是整个项目
- 局部变量的作用域是变量所在的局部范围。而生命周期可能大于作用域，即不是从作用域出来后就被销毁了（用static修饰的变量）。

4.6 常量

- \#define定义的标识符常量

```c
#define max 10；
#define max “scaklhj”
```

## 5.字符串、转义字符和注释

5.1 字符串，自动以\0结尾，而这个\0是我们敲完字符串时，系统自动帮我们加的

```C
char a='asdf';//系统自动输入\0
sizeof(a);   //我们会得到a所占空间大小是5个字节，因为\0算一个字节。
strlen(a);  //结果为4，strlen和printf都是遇到\0就停，只看表面，而sizeof是计算所占空间大小的
```

5.2

- \ddd 表示八进制的数字，d的个数不限，但不能超过8（8进制最大是7）
- \xdd表示十六进制的数字
- 空格也算字符

5.3

- %f float
- %lf double
- %zu 打印sizeof（）返回的值，也可以用%d

## 6.数组

6.1 数组：一组相同类型元素的组合

```C
int    arr1[]={0}    // []会根据后面的{}里面的元素的个数，分配空间                     
int    arr2[2]={0}   // [2]代表2个元素，但后面只有一个数，则系统会自动补充0到数组里                      //  面
char   arr4[2]={'a'} // 系统会自动补充\0， arr字符数组有两个空间，但是后面只有
                     // 一个字符，所以第二个字符自动补\0
```

## 10 操作符

> * 除号的两端都是整数时，执行的是整数除法，如果两端只要有一个浮点数就执行浮点数的除法
>
>   ![image-20220520200335655](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205202003699.png)
>
>   ![image-20220520200457603](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205202004636.png)
>
>   <img src="https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205202005008.png" alt="image-20220520200555972" style="zoom:150%;" />
>
>   ![image-20220520200646968](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205202006015.png)
>
>   
>
> ```C
> float a=10.876;
> printf("%10.1f",a);
> // "10.1f"是指宽度为10，且保留小数点后1位（四舍五入），如果变量宽度不够，则前面补空 // 格，小数点也算一个宽度
> // 如果给的宽度小于变量的宽度则会自动增加宽度，能够正好符合变量的宽度。
> // ".1f"会根据变量的宽度自动调整
> ```
>
> * 取模操作符两个操作符只能是整数
>
> * 初始化：创建变量的同时给变量一个值
>
>   ```C
>   int a=10;//初始化
>   a=20;    //赋值
>   ```
>
> * 单目操作符：只有一个操作数的操作符
>
> ```C
> int a=10;
> printf("%d",sizeof(a));     //sizeof是个单目操作符，后面可以跟变量也可以跟变量类型
> printf("%d",sizeof(int));
> printf("%d",sizeof a);      //因为sizeof是单目操作符，所以后面可以不加括号直接跟变
> printf("%d",sizeof int);    //量名，但不可以直接跟数据类型
> ```
>
> * (数据类型):强制类型转换
>
>   ```C
>   int a=3.14;         //3.14 这种字面浮点数，编译器默认理解为double类型
>   int a=(int) 3.14；  //3.14强制转换成整形
>   ```
>
> * 逗号表达式：逗号隔开的一串表达式
>
>   * 特点：从左到右依次计算，整个表达式的结果是最后一个表达式的结果
>
> ```C
> int a=20;
> int b=3;
> int c=5;
> inr d=(c=a-2,a=b+c,c-3)；
> ```
>
> * 下标引用操作符
>
> * ```C
>   int arr[10]={3};
>   arr[3];           //[]就是下标操作符，arr和3就是[]的操作符
>                                     
>   int n=3；         
>   arr[n]=10;       //[]是操作符，里面可以放变量，当定义arr时，[]是定义语法的一                  // 种形式，所以里面需要放常量,在进行赋值等操作[]可以放变量
>                                                   
>   ```

## 11 关键字

* typedef

  > 类型定义。即类型重命名
  >
  > ```C
  > typedef unsigned int unite_32
  > // 给unsigned int（无符号整形）重新起了个名字，叫做unite_32
  > ```
  >
  > 

* static

  >  修饰局部变量。该变量被修饰后，叫做静态局部变量。
  >
  >  * 改变变量的生命周期，让静态局部变量除了作用域依然存在，直到程序结束，生命周期才结束
  >  * 将原本存在栈区的局部变量，存到静态区。（静态区一般存储全局变量和静态变量）
  >
  >  修饰全局变量
  >
  >  * 被修饰后，使得这个全局变量只能在本源文件被使用
  >  * 全局变量具有外部链接属性和内部链接，一旦被static是修饰后，外部链接属性就被消除了，只剩下内部链接属性
  >
  >  修饰函数
  >
  >  * 被修饰后，使得这个函数只能在本源文件使用，不能在其他源文件内使用
  >  * 函数具有外部链接属性和内部链接，一旦被static是修饰后，外部链接属性就被消除了，只剩下内部链接属性

* const：常属性

  > 一个变量一旦被const修饰后，后面就不能该变，但可以在初始化的时候改变.==使得这个变量具有了常属性，本质还是变量==
  >
  > ```C
  > const int a=1;        //如果想改变，可以从在初始化的地方改变 
  > a=2;                 // a的值不会被改变
  > ```

* extern：声明外部符号的.即在其他源文件定义的

  > 如果一个在其他源文件定义的函数，或者全局变量，如果想被目标源文件使用，必须先声明
  >
  > ```C
  > test1.c
  > int add(int x,int y)
  > int a;//a是全局变量
  > test2.c
  > extern int a;
  > extern int add(int x,inty);
  > ```
  >
  > 

##  12 #define定义常量和宏

```C
#define max 100
//定义常量
#define add（x，y） （（x）+（y））
//定义宏。add：宏名；x，y：参数；（（x）+（y））:宏体
//参数可以是任意类型
```



 ## 13 指针

![image-20220520202252666](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205202022712.png)

<img src="https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205202023468.png" alt="image-20220520202343433" style="zoom: 200%;" />

```C
// 用指针和不用指针加一的区别（针对数组）
    int arr[2] = {0};
    int* p1 = arr;
    int* p2 = &arr;
    printf("%p\n", p1);      //指针的类型决定了指针向前或向后走一步有多大（字节）
    printf("%p\n", p1+1);   //int型指针，+1就是向前走四个字节，所以第二个和第四
    printf("%p\n", p2);     //个输出相等 
    printf("%p\n", p2+1);


    printf("%p\n", arr);      //这里没有把运用指针就直接打印，而且加1，这里向前或向后加
    printf("%p\n", arr+1);    //加一，取决于数组名前面是否有&，有&代表&arr是整个数组的
    printf("%p\n", &arr);     //地址，加一，要前进整个数组大小的字节；没有&则是数组首元 
    printf("%p\n", &arr+1);   //素的地址，加一，取决于这个数组的类型，整型数组则前进4

```

## 控制语句

* C语言的三种基本结构

> 顺序结构
>
> 选择结构
>
> 循环结构

* if 后面如果想跟多条语句，后面必须加{}。；代表一条语句语句的结束。{}里面也会有许多以；结尾的语句，但对于整个程序来说，{}是if的一条语句，if{}else{}又是整个程序的一条语句

* 10<age<20应该写成 age>10&&age<20 这是如果age=5因为先判断5>10为逻辑假0，0<20,为逻辑真，所以10<age<20整体为逻辑真

* 控制语句整体，算一条语句  if {}else{} 是一条语句

* else与离它最近的if匹配

* 程序到return后，就代表结束该部分程序，不是结束整个程序，有返回值，这块程序就结束了

* 当拿一个变量（单纯的变量）判断是否等于一个常量，可以让常量放在前面，`3==a`  

* 表达式不能赋值  变量就只是个变量 不要变形

  ```C
  num%2==2   //num%2是个表达式，不能被赋值，不用写成2=num%2
  ```

* code

```C
//判断一个数是否为奇数	
	int num= 0;
	scanf("%d",&num);
	if ( num % 2==1) {
		printf("奇数");

	}
	else {
		printf("不是奇数");
	}
```

```C
//输出1—100之间的奇数
int i = 0;
for (i = 0; i <= 100;i++) {
	if (i % 2 == 1) {
	printf("%d",i) }
}
```

```C
// switch语句
//switch (整型表达式){
//语句项；        
//}
//语句项：是一些case语句
//case: 整型常量表达式（字符也可以，字符也属于整型）
//语句；
//这个语句有两种形式
//1：表达式；
//2：控制语句（控制语句整体算是一个语句相对于整个程序）。控制语句有两种形式，有时用{}，有时不用，但要当成一个整体 ！   

```



* 在循环中，continue会跳过本次循环，也会跳过continue后面的语句

```C
int ch=getchar(); //获取字符
putchar(ch)       //打印字符
```

* 敲入回车键就是输入\n  敲入回车键 才把字符输入缓存区  而scanf是只要缓存区有字符，就会读取

* 输入\n（就是回车键） 默认输入完毕

* 内存缓存区，在程序执行完后，即出`int main{}`后就被清空，在程序没结束之前内存区有多少字符，scanf函数和getchar函数就得按顺序读取字符

* 当用scanf和getchar函数获得输入时，最后需要敲一下回车键，这是回车键有三个作用
  * 1 换行输出
  
  * 2 将键盘输入的字符传到内存缓存区
  
  * 3 将换行字符一同传到缓存区。scanf会把换行符当成空白字符，而getchar会把换行符读到变量，getchar是用来读字符的，而scanf会遇到空白字符就会停止读取,scanf在停止读取空白字符之前还是会读取空白字符的，只是说空白字符可以当作scanf读取时的结束标志。scanf停止读取后，空白字符并没有消失，还保留在缓存区，等待下一次读取。scanf读数字时，是从所有空白字符后的第一个数字开始读取，读取结束分两种情况，第一格式码前面有限制，即%4d，那就只能读4个数字，数字少了那就读输入的全部数字，如果多了，截取前四个；第二种就是遇到空白字符停止读取。可以看出，scanf不管是读取数字还是字符或者字符串，都是以空白字符结束
  
    ```C
    scanf（"%4d %d %d",&a,&b,&c）； // scanf会忽略空白字符
    //输入：123 空格 12 回车 123
    //当敲回车时，就把123 空格输入进了缓冲区，这时scanf就开始读取了，当读到3时，虽然还没读满4个数，但还是会停止，（scanf遇到空白字符就停止），然后接着从非空白字符读取下一个数字，赋值给b,而不是把空白字符拿走。对于字符串，拿走后，如果还有空间，自动补\0  
    ```
  
    <img src="https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202204222039087.png" alt="image-20220422203921049" style="zoom:200%;" />
  
    ![image-20220520211841229](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205202118267.png)
  
    ![image-20220520212226979](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205202122013.png)
  
* getchar和scanf读到非打印字符时，会把相应的效果输入在窗口，比如ASCILL值 9 用putchar和printf显示时，会空4个格；ASCILL值 32

# 4.15

* if 后面默认跟一条语句，如果想跟多条语句，可以加{}

* `for(i=0;i<10;i++)`可以表示循环10次，如果i从0开始，建议`i<10`这样写

* `for(; ;)`判断部分省略，判断部分恒为真

* 初始化部分最好不要省略

* ===是赋值==，====是判断==

* if 中的continue满足条件 会==跳过==的代码

  ```C
  do
  {
  if (i==5)               
  continue;                  // 当i=5时，continue会跳过后面的代码
  i++;                       // 所以，到4之后就会死循环
  }while(i<10);
  ```

  * 在定义浮点数时，float通不过，可以尝试double
  * int a=5/4 a会取整数部分，不是先得出小数部分，在取余，这是整数的除法，浮点数的除法是要先求出小数的 （这里将被除数或者除数变成浮点数，执行的就是浮点数的除法，即将5或者4变成5.0 4.0）

# 4.17 

* for循环 里面只要有一个判断条件不满足，就结束循环

```C
for (;L<=mid+3,R>=mid;L++,R--)
```

* 写程序最好写一部分，测一部分

# 4.19

* 当不调用函数的时候，形参就不开辟空间

* ``` C
  int arr[10]={0};
  int p=arr;
  arr[2]=*(arr+2);
  *P=arr[0]=*(arr+0）
  ```
  
  

* ```C
  void func(int* arr)
  {
      int b=sizeof(arr)/sizeof(arr[0]); 
      // 在这里sizeof（arr）是首元素的地址，因为传进来的就是首元素的地址，则算的的首元素地址所占内存的大小
      
  }
  
  int main（）
  { 
  
  int arr[10]={12};
  int a=sizeof(arr)/sizeof(arr[0]);
  // 这里sizeof（arr），arr代表的是整个数组，计算的是数组所占空间空间的大小
  }
  ```

  

* 思考问题时，想的应该是内存里的数据，而不是谁代表数据，写的时候要把代表数据的变量名写出来，因为你不可能把数据直接写出来，就像不可能把地址写出来，找个东西代表他，但简单的数据10，直接写出来就行，没必要在找个变量来代表他

* 链式访问:把一个函数的返回值方程另一个函数的参数
* printf返回的是在屏幕打印字符的个数。23这是两个字符（’2‘和‘3’）



# 4.22

* 自己定义的函数文件使用时，就是用双引号，标准库文件就是尖括号

  ```c
  #include<stdio.h>// 标准
  #include"add.c"  // 自定义
  ```

* > 模块化的意思就是把源文件分开写
  >
  > 包含头文件，相当于把头文件的内容拷贝过来

* %d：打印有符号整数（会有正负数）
  %u：打印无符号整数



# 4.23

## 函数栈帧的创建与销毁

* 每一个函数的调用，都要在栈区创建一个空间

* > 压栈（push）：给栈顶放一个元素
  >
  > 出栈（pop）：从栈顶删除一个元素
  >
  > 栈顶指针：esp用来记录栈底的地址 esp+ess
  >
  > 栈底指针：ebp ebp+ess
  >
  > call:调用
  >
  > 寄存器是独立于内存的，集成到cpu的
  >
  > 十六进制后面要加h，在反汇编时

* > 在调用函数之前先将实参压栈（临时拷贝，在main创建的栈帧外 ），再调用函数。在调用函数会马上创建栈帧而且不会再为形参申请空间==是main函数增加栈帧==

* > 返回值时，是将值放在eax寄存器中  返回值时通过寄存器带回来的，没有在在栈区开辟空间

##  扫雷游戏+操作符(1)

1. > 正数的原码、反码和补码一样
   >
   > 负数的反码是符号位不变，其他位加取反，而反码加一就是补码

2. > 画红框中的意思如下，对a进行左移，并不会改变a的值
   >
   > ![image-20220506202055099](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205062020148.png)
   >
   > 
   >
   > ![image-20220506202039787](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205062020827.png)
   >
   > ![image-20220506202227413](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205062022449.png)



3. > * 移位操作符只针对整数，不支持浮点数
   > * 无符号整数，可以看成正数

4. 正数的原码、反码和补码是相同的，所以看到补码的符号位，可直接写出它的原码

## 操作符（2）

1. ```C
   int a=10;
   printf("%d",a--);
   // 打印10
   int a=10;
   test(a--);
   //传进去也还是10
   ```

2. sizeof 是操作符，不是函数。如果是函数，`sizeof a`后面应该是（a） 

3. ![image-20220508110713745](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205081107791.png)

4. ```C
   "abc"=="abcsf";//这是在比较地址
   //应该用strcmp（）；比较字符串
   ```

5. `b=(a>b?a:b);`将条件表达式用括号标起来

6. []

   ```C
   // []是个双目操作符，左值和右值在某些情况下可以交换
   // arr[7]和7[arr]是等同的，sizeof也是个操作符，可以看作和+ -一样的乘除，满足交换律
   // 在定义数组时即，int arr[10]不能写成int 10[arr]
   //arr[7]-->*(arr+7)--->*(7+arr)--->7[arr]
   // arr就是首元素的地址
   // arr+7就是跳过7个元素，指向第八个元素
   // *（arr+7）就是8个元素
   ```

7. 结构体传参，传值和传址

   ```C
   struct stu
   {
     char name[20];
     int age;
     double score;
   };
   void set_stu(struct stu ss)  // 传值进去，编译器会在程序运行时，建立一个新的
   {                            // struct stu ss 最后改变的是ss不是s   
     // ss.name="sgj"; // ss.name是地址，不能以这样给数组赋值
      //ss.name[20]="sgj";// 正确赋值，按照正常的赋值方法赋值就行 
     strcopy(ss.name,"sgj");// 正确赋值
     ss.age=20;
     ss.score=100.0;
   }
   int main()
   {
       struct stu ={0};
       set_stu(s); // 传值
       print_stu(s); //传值
       return 0;
   }
   
   // 传址
   struct stu
   {
     char name[20];
     int age;
     double score;
   };
   void set_stu(struct stu* ss)  // 传址进去，编译器会在程序运行时，改变的是s
   {                               
     // ss.name="sgj"; // ss.name是地址，不能以这样给数组赋值
     strcopy(ss->name,"sgj");// 正确赋值
     ss->age=20; // 传址进去，用->形式调用参数
     ss->score=100.0;
   }
   void printf_stu(struct stu* ps)
   {
       printf("%s %d %lf\n",ps->name,ps->age,ps->score);
   }
   int main()
   {
       struct stu s={0};
       set_stu(&s); // 传值
       print_stu(&s); //传值
       return 0;
   }
   
   ```

8. 位操作符（只适用于整数）

   * &（按位与）：只要有一个为零，对应位就为0
   * 正数和负数的按位与，运算出来的数，在不溢出的情况下，结果是正数
   * 二进制某位为0强行置0，某位为1是还原
   
   
   
   * |（按位或）：只要有一个为1，对应位就为1
   * 正数和负数的按位与，运算出来的数，在不溢出的情况下，结果是负数
   * 二进制某位为1强行置1，某位为0是还原
   
   
   
   * ^(按位异或)：相同为0，相异为1
   
   * 二进制某位为0为还原，某位为1置返
   
   * 正数和负数的按位与，运算出来的数，在不溢出的情况下，结果是负数
   
   * > (a^b)^a=b  (a^b)^b=a 0^a=a a^a=0
     >
     > 异或支持交换律即3^5^3=3^3^5



9. sizeof :操作符

   * 计算的是变量所占内存空间的大小
   * 计算的是类型所创建的变量占据内存空间的大小，单位是字节

   ```C
   sizeof(int);
   sizeof(a);
   sizeof a;// 没有sizeof int
   ```

10. 0可以看成正数，其反码为0000000000000000000（原反补一致）。~0为-1

11. ~的应用：将二进制位的某一位进行修改

    ```C
    int a=13;
    // 补码：00000000 00000000 00000000 00001101
    // 将1101前面的一位变成1
    // 00000000 00000000 00000000 00001101
    //               |（按位或）
    // 00000000 00000000 00000000 00010000  1<<4
    //               =
    // 00000000 00000000 00000000 00011101
    // 即a|=(1<<4)
    // 上面是将某一位变成1
    // -----------------------------------------------------
    // 将上面变成的位变回0
    // 00000000 00000000 00000000 00011101
    //               &（按位与）
    // 11111111 11111111 11111111 11101111
    //               =
    // 00000000 00000000 00000000 00001101
    
    // 11111111 11111111 11111111 11101111
    //                ^
    //                | 
    //~（00000000 00000000 00000000 00010000）
    //                ^
    //                | 
    //         1<<4
    // 即 a&=~（1<<4）
    // 这是将某位变成0
    ```


## 操作符（3）

* 无符号整型提升，提升了精度，一般不会改变大小

* char 类型所存储的数的范围：-128~127

* 截断是从低位到高位截，即从右到左截

* 优先级是指相邻操作符

* 尽量写出唯一路径，或者加括号

  * > 算术运算符  + - * / %
    >
    > 赋值运算符 =
    >
    > `long a=4`可能会整型提升，因为4是int型，存到long中，整型提升。但算术运算（上面的算术运算符），是以缺省值运行的
    >
    > ![image-20220509210801394](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205092108453.png)

* 整型提升是按照变量的数据类型的符号位来进行提升的

* ![image-20220509213104748](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205092131794.png)

* >  操作数都要转成排名最高的数据类型
  >
  > ![](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205092135582.png)

* > ==这告诉我们以后，尽量不去碰复杂表达式，宁愿多写点步骤，也不可为了方便写在一起==
  >
  > 对于表达式，先从整体上来看，找出优先级最大的操作符，如果有若干个相同的操作符，系统并不能指定将这几个优先级相同的操作符，全部计算完，再计算次一级的操作符
  >
  > ![image-20220509221003896](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205092210000.png)
  >
  > 不同的编译器有不同的规定，有的是全部算完，有的是先算一部分
  >
  > ```C
  > // 例：
  > // Vs2019
  > int a=1;
  > int b=(++a)+(++a)+(++a);
  > // 结果就是b=12
  > // 这里就是先将括号先计算完。值得注意的是，+操作符的的左操作数的获取 // 是在获取右操作数之后求值的
  > // Linux
  > // 结果b=10
  > // 那这里就是先将前两个括号计算出来。值得注意的是，和Vs一样，+操作符的的左操作数的获取是在获取右操作数之后求值的
  > ```
  >
  > ![image-20220509221923981](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205092219034.png)

* > * 0xb6的二进制数是10110110，如果是写成32位就是00000000000000000000000010110110，因为a是char类型只能放八位，所以从左到右截断就是11111111，放到char类型的空间（也即1个字节），又因为char是有符号，所以存进去的最高位成了符号位，下面进行==操作时，会进行整型提升，因为最高位时是1，所以提升后的结果是11111111111111111111111111111111，所以成了负数。
  >
  > * 启发：内存空间存的只是一串二进制序列，当程序有不同的要求，会将这些二进制序列转换成对应的符号，例如，printf("%c",a),系统就会把存在a中的二进制序列先进行整型提升，然后找对应的字符
  > * short是2个字节
  > * 整型提升就是将存储的二进制序列进行精度提升
  >
  > ![image-20220510194542142](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205101945247.png)
  >
  > 

## 初阶指针

1. > int型指针放到char指针会出现下述情况，需要强制类型转换，即`char* a=(char*)&a` 
   >
   > ![image-20220511204303470](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205112043589.png)

2. > 指针就是地址，通常指的就是指针变量，是用来存放指针变量的，且指针中的数值都被当地址处理。
   >
   > ```C
   > int* p=0;     // 指针的数据类型也可以看成无符号整型，所以像这样放值进去的时候               // ，当成一般的存放数值处理即可  
   > int* p=NULL;  // 和上面的的效果一样，NUll是#define （*void）0
   > // 那么p里面放的全部是0，也就是指向地址全是0的内存空间
   > ```
   >
   
3. > * X86是指32根地址线，即指针的大小是4个字节；而X64是64跟地址线，即指针字节的大小是8个字节。
   > * sizeof返回的是无符号整型，对应%zu（专门对应sizeof）
   >
   > ![image-20220511221509228](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205112215314.png)

4. > ==int* p=&a。p里面放的是变量所表示的内存空间的地址，只不过a的内存空间的地址，与首字节的地址一样==

5. > 指针的类型决定了，解引用的所操作的内存空间和向前或向后一步走一步的剧里有多大
   >
   > `char* `的指针解引用就只能访问一个字节，而int*指针的解引用就能访问四个字节==后续加例子==

6. > *vp++的（ *vp ）++的区别
   >
   > ```C
   > // *vp++ 按优先级，先算++，但因为是后置++，虽然vp++，但接下来参与运算 //的是/ // 没有++的vp，然后进行解应用，所以后置++，是先使用后++，可这个++是对vp单独进 // 行操作的，因为++是个单目操作符，至于操作后的结果怎么使用，就要看是前置还是后 // 置++。最后的结果是，先是vp+1，然后取出p里面的地址
   > // （ *vp ）++ 因为（）的优先级最高所以先算对vp进行解引用，然后++，结果就是地址加一
   > ```
   >
   > * *vp解引用出来的不是地址，是地址所指向的值

7. >     指针—指针得到是指针之间元素的个数，且只有指向同一块空间的指针才可以相减
   >
   >  ![image-20220512193931901](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205121939032.png)

8. > * 不同类型指针解引用后，操作的空间不同，char型指针解引用后只能操作一个字节，而int型指针，解引用后只能操作4个字节的空间。
   > * ==想对指针指向的内存空间修改元素，必须得解引用，即*p==
   >
   > <img src="https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205122019182.png" alt="image-20220512201947128" style="zoom:200%;" />
   >
   > <img src="https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205122020224.png" alt="image-20220512202003168" style="zoom:200%;" />
   >
   > ![image-20220512202008729](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205122020791.png)

## 初识指针（2）+结构体

1. > `int* p`,中的*，表示p是个指针，int表示指针指向的对象是个整型;`int** p 等价于int*   *p `，指针p指向的对象是个指针

2. > * 二级指针是用来存放一级指针变量的地址的
   >
   > * 指针数组，全称应该是指针变量数组，是用来存放指针的。例，`int* p[]={&a,&b}`
   >
   > * 考虑优先级的问题，对于指针数组的某个元素进行解引用时，应该带括号解引用
   >
   >   即，`*(arr[1])`

3. > 浮点数不能在内存空间中准确存储，即`float a=3.14f`,内存中存储可能是3.12=40000001

5. > * n&(n-1),会从左到右把n的二进制位的1消掉一个
   >
   > * 如果要求n是否为2的n次方，则可以利用`0 == n&(n-1)`,因为如果是2的n次方，总有一位等于0，例2的3次方的二进制就是100，2的5次方就是10000

6. > * 全局变量和静态变量都放在静态区，如果不初始化，则默认初始化为0，但局部变量是放在栈区，如果不初始化，默认是随机值

##  实用调用技巧(1)

* > * F5跳到下一个逻辑断点
  >
  > * 禁用断点，可以不删除断点，只是让它在某一过程不起作用(断点处右击鼠标)
  >
  > * 条件断点（断点处右击鼠标）。在循环中可以跳到自己想要的循环次数处。==断点是判断上一句执行完，停在设断点的语句，而设断点的语句是没有被执行的；而条件断点是判断断点上一句是否符合条件，如何符合条件，即停在断点处，不符合则不会停止==
  >
  > * 如果断点设在下方所在位置，所指的意思是循环全部结束，即到该断点时，i==10
  >
  >   ![image-20220516222353057](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205162223100.png)





* >  局部变量和自动窗口的区别
  >
  > 在调试时，“自动变量”和“局部变量”窗口会显示变量值。 仅在调试会话期间，这两个窗口才可用。 “自动变量”窗口显示当前断点周围使用的变量。 “局部变量”窗口显示在局部范围内定义的变量，通常是当前函数或方法

* >  在监视窗口数组a，1，前n的元素数组
  >
  > ![image-20220516222806205](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205162228236.png)

* > 在内存的监视中，红框所在地方可以改变一行显示的字节数
  >
  > ![image-20220516201020697](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205162229352.png)



* >  删除键可以删除变量在监视窗口中

* > ![image-20220517213035651](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205172130888.png)

* > ![image-20220517214804793](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205172148857.png)

* > assert:
  >
  > 对于断言，相信大家都不陌生，大多数编程语言也都有断言这一特性。简单地讲，断言就是对某种假设条件进行检查。在 C 语言中，断言被定义为宏的形式（assert(expression)），而不是函数，其原型定义在<assert.h>文件中。其中，assert 将通过检查表达式 expression 的值来决定是否需要终止执行程序。也就是说，如果表达式 expression 的值为假（即为 0），那么它将首先向标准错误流 stderr 打印一条出错信息，然后再通过调用 abort 函数终止程序运行；否则，assert 无任何作用。
  >
  > 默认情况下，assert 宏只有在 Debug 版本（内部调试版本）中才能够起作用，而在 Release 版本（发行版本）中将被忽略。当然，也可以通过定义宏或设置编译器参数等形式来在任何时候启用或者禁用断言检查（不建议这么做）。同样，在程序投入运行后，最终用户在遇到问题时也可以重新起用断言。这样可以快速发现并定位软件问题，同时对系统错误进行自动报警。对于在系统中隐藏很深，用其他手段极难发现的问题也可以通过断言进行定位，从而缩短软件问题定位时间，提高系统的可测性。

## 实用操作符（2）

* NULL指针不能解引用后赋值，即`char* p=NULL;*p=0;`

* > 程序出现的三种错误
  >
  > test.c------------------------------------------------------------------------------------>test.exe(可执行程序)
  >
  > ​           |                                                                            |
  >
  > ​           编译（将高级语言翻译成机器语言）             链接
  >
  > * 编译错误。即语法错误
  > * 链接错误。引用某函数，却没该函数的定义
  > * 运行时的错误。

* > 任何一个变量/表达式都有两个属性
  >
  > * 值属性
  >
  > * 类型属性
  >
  >   ```C
  >   int a=0;
  >   char b=0;
  >   int* p1=&a;  
  >   char* p2=&b
  >   char* p2=(char*)p1; // 将指针变量p1的值赋给p2，体现了p1的值属性；在赋值
  >                       // 之前又进行了强制类型转换，体现了p1类型属性，也就 
  >                       // 是说，赋值时应该类型一致，如果类型不一致，要么强制                     // 类型转换，要么系统转换，这样产生损失精度等一些问                     // 题，要么报错
  >   ```

* >  当一个数是a=11223344时，在内存中的存储是从低地址到高地址，则低字节放在低地址，高字节放在高地址，即内存的样子是 44332211

* > scanf函数在读字符串时，运到空白字符（换行 空格 tab）就会停止读取，要是读取带空格的字符串就不适合了，这时`char arr[12];gets（arr）;`更加适合
  >
  > ![image-20220519200156718](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205192001791.png)
  >
  > ![image-20220519200238559](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205192002628.png)

## 数据存储（1）

* > char到底是signed还是unsigned，取决于编译器的类型，C语言是没有规定的。vs2019是有符号的

* > 4的进制表示
  >
  > 二进制 100（无格式码）
  >
  > 十进制 4 （格式码%d）
  >
  > 八进制 04（格式码%o）
  >
  > 十六进制0x（格式码%x，输出是小写，%X输出是大写） 

* > 负数的补码的两种求法
  >
  > 1. 原码求反加1 (补码转原码，也可以求反加一，也可以减一求反)
  >
  > 2. 设负数为a，则补码是 (2^n)-|a|=b,b的二进制就是补码，n是想输出的总位数。
  >
  >    例：a=-4 求其8位二进制的补码，那就是b=2^8-4
  >
  >    技巧：如果位数太多，而a的值又太小，可以将2^n拆分成c+2^N-a,N是位数，N的选择应该使得2^N大于或等于|a|，在所有可选择的中应该选择最小的N，求出的数再与c相加，而是是前n-N位都是1，后N位为0，求出的数最后与c的二进制位相加一定得是N位二进制数
  >
  >    二进制表示 求32位a=-5的补码 ，则应选N为3，求出的数为3，二进制为011，c的二进制位表示则是111111111111111111111000  最后相加得出为111111111111111111111011

* > ![image-20220523210721280](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205232107327.png)
  >
  > ![image-20220523212851864](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205232128908.png)
  >
  > ==这说明在内存中存的只是一些二进制序列，读取时根据类型去读取，例如110，可以看成有符号的-2，也可以看成无符号数的6；对于无符号和正数在内存中的二进制数列是一样，只不过正数的最高位为符号位0。一开始数据从内存空间存到寄存器，因为寄存器一般是32位的，对于小于32位数据，需要先进行整型提升才能送到寄存器，从寄存器中读取时，要看格式码是什么例，%d则从寄存器读取32位且按有符号读取，从寄存器送到内存空间，送多少位，要看内存空间是什么类型的，如果是char就从低位到高位送8，int型则送32位==
  >
  > ![image-20220523213657611](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205232136650.png)
  >
  > * %d 有符号32位 %u 无符号32位
  >
  > * char a=128;  000000000000000010000000 截断成八位，即100000000，a的最大应该是127，但因为截断放的是和-128的补码一样了，到最后怎么去看a，还是看怎么取读取，如果读有符号%d那就是-128，如果是%u，那就是很大的数。
  >
  > * ==从内存空间-------------------------->寄存器  如果小于32位则中间过程会发生整型提升；寄存器（或立即数）------------------------------------->内存空间，如果读取的要求小于32位则会发生截断吗，这是两个过程==
  >
  > * 有符号的数一定得用有符号的格式码进行输出
  >
  > * 有符号数的最高位扩展，如果还是有符号输出，扩展只是提高精度，对原来的数值不发生影响
  >
  >   如：char a = 1;1是字面常量，也要先写成32位的，再进行截断，就像上面的例子128，如果不展开，128是放不进去a的内存空间的，因为a最大才是127，但先展开成了32位，存进a中时发生了截断。在内存占一个字节，二进制序列就是00000001 进行运算时，算到寄存器中，因为char时又有符号的所以，扩展符号位，就是000000000000000000000001 ，按%d输出，输出还是1，不影响a的数值。
  >
  >   * 字面常量是通过立即数的方式送进去的，但还是按照32位进行截取
  >
  >   ![](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205232208842.png)

## 数据在内存中的存储

1. > * strlen 返回的是无符号整数（size_t:unsigned int ）
   > * 两个无符号相减还是无符号数（和类型的转换有关）

2. > 小端存储：低位放低地，高位放高地址。具体应该是，一个二进制序列的低位字节放低地址，高位字节放高地址。
   >
   > 如果以字在内存窗口中显示时，显示的从低位到高位字单元的里面数的大小，整体还是从低地址到地址。值得注意的是，在一个字节中前四位还是放进去的二进制序列的高四位。
   >
   > ![image-20220525211135551](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205252111642.png)

## 指针进阶

1. char *p="sgj"; "sgj"是个常量字符串，放在了一块只能放不能该的内存中，所以不能被修改。

   p="sgji",编译会通不过，运行时才会保存

   最好的方法是const * p=“sgj” ，这样编译时就会报错

2. sizeof（arr+0）,这不算，sizeof（arr）,这里的arr表示整个数组，计算的是整个数组的大小，arr表示整个数组的指针在这里。这里值得注意的是，一旦arr被传参，sizeof（arr）的就是arr这个指针所占空间的大小

   <img src="https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202205301939772.png" alt="image-20220530193946721" style="zoom:200%;" />



  

5. 函数名和&函数名

   > 都是函数的地址。函数名可以从两个角度去看
   >
   > * 一是函数名是个变量，里面装的是函数的地址    
   > * 二是在编译的时候，函数名可以看作是函数的地址

   ```java
   int (*p)(int, int)=add
   int a = (*p)(2,3)     
   int a = *p(2,3)   //这是错的，因为p（2，3）的结果再解引用
   int a = p(2,3),直接写p也可以
   ```

   

6. 函数的地址和全局变量的地址，都在编译期间就给好了，函数是没有首地址的概念的

7. 函数名与sizeof<img src="https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206031930428.png" alt="image-20220603193040382" style="zoom:150%;" />

​           ![image-20220603193053788](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206031930839.png)



8. > 函数声明
   >
   > ```C
   > int add(int a, int b)
   > {
   >    return 0;
   > }
   > int add(int , int);//声明后面加个分号
   > ```
   >

9. > void(  *signal(int, void( * )( int) )  )( int );
   >
   > * signal(int, void(*)(int)),是函数，void( * )(int)
   > * 以上代码是一次signal的函数声明，该函数的第一个参数int,第二个参数的类型是函数指针，返回值类型也是也是一个函数指针
   >
   > 启发：
   >
   > * 在定义变量、声明返回值的类型或者重定义，但不管是哪一种情况，变量也好，函数也好，都要放在p处，即变量名称处，就如函数指针类型int (* ) (int),函数名放在括号里的 * 后面。  下面图片的含义是把void(*)(int),这样的数据类型重定义成pf_t
   > * 

   

10. > qsort 使用快速排序的思想的排序函数，可以排序任意类型的数据。#include<stdio.h>
    >
    > void qsort(void* base ,size_t num,size_t width,int(*cmp)(const void * e1, const void * e2))
    >
    > * void* base：排序的数据的起始位置
    > * size_t num：待排序数据元素有几个
    > * size_t width：待排序的数据元素的大小，占几个字节
    > * int(*cmp)(const void * e1, const void * e2)：cmp是比较函数，e1，e2是需要比较函数的元素

11. > void* e1，void* 的指针是不能直接解引用操作的，即不能*e1.
    >
    > * void* 是没有具体指针类型的指针，可以接受任意类型的地址，所以不能解引用操作
    >
    >   也不能进行加1，减18
    >
    > * 所以想解引用时，需要先把指针强制类型转换，但前提是强制类型转换的数据类型得是根据背景的出来的，不能强制类型转换，一定是有助于帮助我们解决问题

12. > 可见强制类型转换要比->的优先级要低，所以要加括号即((struct stu*)e1)
    >
    > ![image-20220605092426910](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206050924959.png)

13. > ![image-20220605094313827](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206050943868.png)



15. > 在定义数据时，如果不初始化，那么[]里面就得有常量，不然会报错
    >
    > ![image-20220605153455423](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202206051534514.png)



## 7.1

1. 指针的类型的意义

   + +1/-1操作的步长

   + 解引用操作的时候的权限

     ```java
     int a = 10;
     char* b = (char*)&a;
     *b = 1;
     // *b: 对b进行解引用操作的字节数就是1个
     // 解引用操作的权限是指：所操作的字节数，如果double*类型，所操作的字节数就是2个
     ```

     

2. 数组名 VS &数组名

   * 大部分情况下指，数组首元素的地址

   + 两个例外
     + sizeof(数组名)：整个数组的大小。
     + &arr：整个数组的地址。（对整个数组的地址进行解引用返回的首元素的地址，也就是说得两次解引用才可以返回首元素的值，即**arr，这里指的是一位数组，二维数组得三次解引用）

3. 函数指针

   ```java
   // 下面四种形式都是对的
   // add既是函数变量，也代表所带空间的地址，跟数组名有点类似
   int (*p)(int, int) = &add;
   int (*p)(int, int) = add;
   int a = *p(2,3);
   int b = p(2, 3);
   ```

4. 函数指针数组和指针数组

   * 函数指针数组：int (*pArr[])(int , int)
   * 指针数组：int (*p)[10]
   * 总结：
     + 像上面两种，又带括号，又带[],可以先确定是这个变量的类型，再确定变量的是什么变量。
     + pArr先与[]结合，说明pArr是个数组，那就拿掉pArr[],来判断是什么变量，int(* )(int, int),是个函数指针的类型，所以是个pArr函数指针数组。
     + p先与*结合是个指针，int[]是个数组，所以p是个数组指针
     + 有点像，先确定变量的本质，再确定其修饰。

5. 指针相关的题

   * sizeof和strlen
     + strlen是求字符串长度，关注的是字符串中的\0,计算的是\0之前出现的字符个数
     + strlen是库函数，只针对字符串
     + sizeof只关注内存空间的大小
     + sizeof是操作符

   * 一维数组

     ```C
     int a[] = {1,2,3,4};
     // 16 size(数组名),数组名代表整个数组，计算的是整个数组的大小，单位是字节  
     printf("%d\n",sizeof(a));
     
     // 4/8 a代表首元素的地址，加几就代表偏移几，最终算的是地址的大小             4/8; 在这里 a == &a[0],取首元素的地址
     printf("%d\n",sizeof(a+0));
     
     //  4 *a取出首元素，计算的首元素的大小，即数据类型的大小，这里是int，所以是  4
     //    a == &a[0] *a == *&a[0] *a == a[0] *&从某个角度来讲，可以抵消
     printf("%d\n",sizeof(*a));
     
     //  4/8 地址进行偏移1，
     printf("%d\n",sizeof(a+1));
     // 4
     printf("%d\n",sizeof(a[1]));
     
     // 4/8 &a,取出的是数组的地址，即int(*)[4]，但地址的大小不是4就是8
     printf("%d\n",sizeof(&a));
     
     // 16 对数组的地址，进行解引用，返回的是整个数组，所以返回16
     printf("%d\n",sizeof(*&a));
     
     // 4/8 对数组的地址偏移1，得到的还是一个地址，不过是地址加16，返回4或者8
     printf("%d\n",sizeof(&a+1));
     
     // 4/8 取出第一个元素的地址
     printf("%d\n",sizeof(&a[0]));
     
     // 4/8 取出第一个元素的地址后偏移1
     printf("%d\n",sizeof(&a[0]+1));
     ```

   * 字符数组

     * &变量 + 1，实际地址加上改变量数据类型的大小，如，变量是指针，加1，实际地址就得加4；变量是char，加1，实际地址就是加1。除变量是数组名外，实际地址加的就是整个数组的大小

     ```C
     char arr[] = {'a','b','c','d','e','f'};
     // 6 
     printf("%d\n", sizeof(arr));
     
     // 4/8
     printf("%d\n", sizeof(arr+0));
     
     // 1 *arr-->*(arr + 0) -->arr[0]
     printf("%d\n", sizeof(*arr));
     
     // 1
     printf("%d\n", sizeof(arr[1]));
     
     // 4/8
     printf("%d\n", sizeof(&arr));
     
     // 4/8
     printf("%d\n", sizeof(&arr+1));
     
     // 4/8 
     printf("%d\n", sizeof(&arr[0]+1));
     
     // strlen求字符串的长度，以\0结尾
     // strlen从arr地址开始找，直达找到\0结尾
     // 随机值
     printf("%d\n", strlen(arr));
     
     // 随机值
     printf("%d\n", strlen(arr+0));
     
     // strlen函数的形参是地址，所以传给strlen函数的数值默认是地址，这里传的是'a'的Acill码值97，97成了野指针，
     // 不能随便访问，非法访问，程序报错
     printf("%d\n", strlen(*arr));
     
     // 野指针，非法访问
     printf("%d\n", strlen(arr[1]));
     
     // 取出数组的地址，传给strlen，转成char*，随机值
     printf("%d\n", strlen(&arr));
     
     // 随机值减6, 也存在越界访问，不是那么危险，有时就不会报错
     printf("%d\n", strlen(&arr + 1));
     
     // 随机值减1
     printf("%d\n", strlen(&arr[0] + 1));
     
     
     char *p = "abcdef";
     // 7
     printf("%d\n", sizeof(p));
     // 4 /8 首元素地址加1，还是地址 
     printf("%d\n", sizeof(p+1));
     // 1
     printf("%d\n", sizeof(*p));
     // 1
     printf("%d\n", sizeof(p[0]));
     // 4/8 取出变量p的地址
     printf("%d\n", sizeof(&p));
     // 4/8 &q,取出p的地址加偏移1，实际地址加4
     printf("%d\n", sizeof(&p+1));
     // 4/8 取出首元素的地址加1
     printf("%d\n", sizeof(&p[0]+1));
     // 6
     printf("%d\n", strlen(p));
     // 5
     printf("%d\n", strlen(p+1));
     // err
     printf("%d\n", strlen(*p));
     // err
     printf("%d\n", strlen(p[0]));
        
     // 随机值，&P,&取地址，取的是变量p的地址，不是P里面存放的地址
     printf("%d\n", strlen(&p));
     // 随机值，p是char*，不是数组指针
     printf("%d\n", strlen(&p+1));
     // 5
     printf("%d\n", strlen(&p[0]+1));
     
     
     ```

     ![image-20220713124729918](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202207131247968.png)

     ![image-20220713150857318](https://dawn1314.oss-cn-beijing.aliyuncs.com/202207141006707.png)

   * 二维数组

     + 对一维数组地址的解引用，例如，sizeof(a[0])一维数组的大小
     
     + a[1] [2] == *( *(a + 1) + 2)， *（a + 1），得到的是一维数组的首元素的地址
     
     + a[0],如果既没有sizeof(arr[0])(返回一维数组数组的大小)，也没有&a[0] (取出数组的地址)，那么a[0]就是一维数组首元素的地址
     
     + sizeof计算的数据类型的大小
     
     + a[0]是第一行这个一维数组的名，单独放在sizeof内部，a[0]表示第一个这个一维数组，
     
       sizeof(a[0])计算的是这一行的大小
     
     + a[0]并没有单独放在sizeof内部，也没取地址，a[0]就代表首元素的地址，就是第一行这个一维数组的第一个元素的地址，例如：sizeof(a[0] + 1)),a[0] + 1代表第一行第二个元素的地址
     
     + sizeof只要知道数据类型就可以知道占几个字节。
     
       ```java
       int a = 1;
       // 从下面就可以知道，sizeof只要知道数据类型就可以知道占几个字节
       sizeof(int);
       // sizeof是通过分析a的数据类型，得到占几个字节的，并不会真的取访问a
       sizeof(a);
       ```
     
     ```java
     int a[3][4] = {0};
     printf("%d\n",sizeof(a));
     printf("%d\n",sizeof(a[0][0]));
     // 16 a[0]是指第一个一维数组的地址，也就是数组地址
     printf("%d\n",sizeof(a[0]));
     // 4 a[0] + 1 == &a[0][0],代表首元素的地址
     printf("%d\n",sizeof(a[0]+1));
     // 4 第一行第二个元素的大小
     printf("%d\n",sizeof(*(a[0]+1)));
     // a虽然是二维数组的地址，但是并没有单独放在sizeof内部,也没有取地址
     // a表示首元素的地址，二维数组的首元素是他的第一行，a就是第一行的地址
     // a+1,就是第二行的地址，是地址就是4/8
     printf("%d\n",sizeof(a+1));
     // 16 对第二行地址进行解引用，得到的是第二行的大小 
     // *(a + 1) = a[1]
     printf("%d\n",sizeof(*(a+1)));
     // &a[0],对一行的数组名取地址，拿出的是第一行的地址;&a[0] + 1得到的是第二行的地址
     printf("%d\n",sizeof(&a[0]+1));
     // 16
     printf("%d\n",sizeof(*(&a[0]+1)));
     // 16 a这里是第一行数组的地址，也就二维数组的首元素的地址，解引用后就是一维数组的大小
     printf("%d\n",sizeof(*a));
     // 16 sizeof不会访问第四行的元素的(不存在)，通过分析二维数组a，得到所占字节多少
     printf("%d\n",sizeof(a[3]));
     
     ```

6. 指针相关的面试题

   * ```C
     #include<stdio.h>
     int main(){
         int a[3][2] = {(0,1), (2, 3), (4, 5)};
         int *p = a[0];
         printf("%d", p[0]);
     }
     
     // 思路
     // (0,1)是逗号表达式，所以a = {1, 3, 5}
     ```

   * ```C
     // 对一个一维数组的地址进行解引用，返回的这个一维数组的首元素的地址
     int main()
     {
     int aa[2][5] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
     int *ptr1 = (int *)(&aa + 1);
     int *ptr2 = (int *)(*(aa + 1)); // *(aa + 1) == aa[1] 二维数组aa第二个元素的地址
     printf( "%d,%d", *(ptr1 - 1), *(ptr2 - 1));
     return 0;
     }
     ```

   * notition:

     + %s会根据地址一直找到\0才返回打印
     + cpp[2] == *(cpp + 2) ,在加2的过程中，cpp的大小不会改变

     ```C
     
     // %s会根据地址一直找到\0才返回打印
     
     int main()
     {
     char *c[] = {"ENTER","NEW","POINT","FIRST"};
     char**cp[] = {c+3,c+2,c+1,c};
     char** *cpp = cp;
     printf("%s\n", **++cpp);       // "POINT"
     printf("%s\n", *--*++cpp+3);   // "ER"
     printf("%s\n", *cpp[-2]+3);    // "ST"
     printf("%s\n", cpp[-1][-1]+1); // "EW"
     return 0;
     }
     ```
     
     ![image-20220713222017238](https://dawn1314.oss-cn-beijing.aliyuncs.com/typora202207132220310.png)





## 7.10

1. **数据类型**

   * 内置数据类型
     + char、double、int、float、double

   + 自定义数据类型
     + 结构体、联合体、枚举

2. **结构体的声明**

   * ```C
     // 这只是简单创造了一个数据类型，跟int、float差不多，所以不用初始化
     // tag称作结构体的标签
     // struct tag 合在一起叫做结构体数据类型
     struct tag   
     {
     member-list;
     }variable-list;
     
     // 第一种写法
     struct stu{
         chat name[];
     };
     
     // 第二种写法 在创建数据类型的同时，也创建了s1、s2变量
     struct stu{
         chat name[];
     }s1, s2;
     
     // 第三种写法 标签名可以不写，称作匿名结构体类型，只能用一次，
     // 即，创建对象只能在下面创建，如s1，在main里面无法创建
     struct   
     {
     member-list;
     }s1; // 这里必须有变量，且初始化只能在这个位置
     ```

   * ```C
     // 匿名结构体
     struct
     {
     int a;
     char b;
     float c;
     }a[20], *p;
     // a[20],创建一个数组元素为该结构体类型的数组大小为20的数组
     // *p，创建一个匿名结构体的指针
     
     struct
     {
     int a;
     char b;
     float c;
     }x;
     
     p = &x;
     // 编译器报警告，"从*到*不兼容"
     // 虽然上面两个匿名结构体的成员都相同，但是在编译器看来，两个
     // 匿名结构体依然是不同的数据类型
     ```

3. **结构体的自引用**

   * ```C
     struct Node
     {
     int data;
     struct Node* next;
     };
     ```

   * ```C
     // 匿名结构体没办法自引用
     // 一种错误的想法：匿名结构体自引用时，还得需要匿名结构体的名字(标签)，所以将匿名结构体重命名一个名字，这种想法是错误，因为重命名得需要有标签。
     // 既然选择了匿名，就没必要再重命名
     typedef struct
     {
     int data;
     Node* next;
     }Node;
     
     // 正确
     // 需要注意的是，结构体里面还是数据里结构体数据类型的全称，即struct node
     // 但以后创建struct node变量时，可以直接‘Node 变量名’
     typedef struct Node
     {
     int data;
     struct Node* next;
     }Node;
     ```

   * ```C
     // typedef重命名结构体指针
     // 第一种写法
     typedef struct Node{
         int data;
     }* LinkedList;        // 在创建数据类型时，将结构体指针重命名
     
     // 第二种写法
     struct Node{
         int data；
     };
     typedef struct Node* LinkedList;
     ```

   

4. **结构体变量的初始化**

   * ```C
     struct Point2
     {
     int x;
     int y;
     }p1; //声明类型的同时定义变量p1，且初始化，在这里就没有初始化，那就系统默认初始化
     
     struct Point p2; //定义结构体变量p2
     //初始化：定义变量的同时赋初值。
     struct Point p3 = {x, y};
     
     struct Stu s//类型声明
     {
     char name[15];//名字
     int age; //年龄
     };
     struct Stu s = {"zhangsan", 20};//初始化
     
     struct Node
     {
     int data;
     struct Point p;
     struct Node* next;
     }n1 = {10, {4,5}, NULL}; //结构体嵌套初始化
     struct Node n2 = {20, {5, 6}, NULL};//结构体嵌套初始化
     ```

   * ```C
     struct Point2
     {
     int x;
     int y;
     }p1; //声明类型的同时定义变量p1，且初始化
     // p1的初始化只能在这里，不能被修改
     // 即p1在上面没有初始化，后面就不能p1 = {1， 2}
     ```
   
     ![image-20220715110522681](https://dawn1314.oss-cn-beijing.aliyuncs.com/202207151105772.png)

5. **pratices**

   * printf("%s",arr);  %s 打印字符数组，也就是字符串，是不看这个字符数组是否以\0结尾

   * ![image-20220715111722268](https://dawn1314.oss-cn-beijing.aliyuncs.com/202207151117317.png)

   * 不管是匿名结构体，还是其它类型的结构体，如果在创建结构体数据类型时，也创建变量，这个变量的初始化只能在这个位置，放在其他位置就成了不该修改的左值

     ![image-20220715113300363](https://dawn1314.oss-cn-beijing.aliyuncs.com/202207151133406.png)

   + ![image-20220715114212787](https://dawn1314.oss-cn-beijing.aliyuncs.com/202207151142823.png)
   + ![image-20220715114407308](https://dawn1314.oss-cn-beijing.aliyuncs.com/202207151144342.png)





## 7.11

1. **==结构体内存对齐==**

   * **首先得掌握结构体的对齐规则：**

     + 第一个成员在与结构体变量偏移量为0的地址处。
     + 其他成员变量要对齐到偏移量是对齐数的最小整数倍的地址处，最小整数倍是从已被其他成员变量的地址往下，开始找
       + 对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。
         VS中默认的值为8
       + gcc是没有默认对齐数的，那么默认对齐数就是自己
     + 结构体总大小为最大对齐数（每个成员变量都有一个对齐数，max（num1， num2， num3....））的最小整数倍，其大小要足够包容所有的成员变量。
     + 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最小对齐数的整数倍处（嵌套结构体的大小为16，他的对齐数就是16，就不和默认对齐数去比较了），结构体的整
       体大小就是所有最大对齐数（含嵌套结构体的对齐数）的最小整数倍。

   * **原因**

     + 平台原因(移植原因)：
       不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

     + 性能原因：
       数据结构(尤其是栈)应该尽可能地在自然边界上对齐。
       原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

       ![image-20220715200648691](https://dawn1314.oss-cn-beijing.aliyuncs.com/202207152006745.png)

     + 总体来说：

       结构体的内存对齐是拿空间来换取时间的做法。

     + 那在设计结构体的时候，我们既要满足对齐，又要节省空间，如何做到：
       让占用空间小的成员尽量集中在一起。

   * **修改默认对齐数**

     + 一般设置默认对齐数的大小是2的n次方

     ```C
     #include <stdio.h>
     #pragma pack(8)//设置默认对齐数为8
     struct S1
     {
     char c1;
     int i;
     char c2;
     };
     #pragma pack()//取消设置的默认对齐数，还原为默认
     #pragma pack(1)//设置默认对齐数为1，某种程度来说，就是不设置默认对齐数
     struct S2
     {
     char c1;
     int i;
     char c2;
     };
     #pragma pack()//取消设置的默认对齐数，还原为默认
     
     int main()
     {
     
     printf("%d\n", sizeof(struct S1));
     printf("%d\n", sizeof(struct S2));
     }
     ```

   * **others**

     + ![image-20220715191522314](https://dawn1314.oss-cn-beijing.aliyuncs.com/202207151927991.png)

     + offset(宏) ：求结构体中的某个成员变量的偏移量，相对首字节处

       ![image-20220715193309232](https://dawn1314.oss-cn-beijing.aliyuncs.com/202207151933271.png)

     + ![image-20220715194057059](https://dawn1314.oss-cn-beijing.aliyuncs.com/202207151940129.png)
     + ==大小端是指的字节地址的顺序，即低位字节放在低地址，而在字节内部，就不是大小端的问题，不过从测试来看右边是低位，左边是高位。地址是按字节分的。一个字节就没有大小端问题了。==
     + ![image-20220715205353267](https://dawn1314.oss-cn-beijing.aliyuncs.com/202207152053320.png)

     

2. **==位段==**

   * **定义和注意:**

     * 结构体讲完就得讲讲结构体实现位段的能力。也就是位段需要通过结构体来实现。

       位段的位是指比特位。

     * 位段的声明和结构是类似的，有两个不同：

       + 位段的成员必须是int、unsigned int 或signed int等整形家族的成员 。
       + 位段的成员名后边有一个冒号和一个数字（比特位）。

       ```C
       struct A
       {
       int _a:2; // a需要分配2个比特位,取值比较有限
       int _b:5; // b需要分配2个比特位，指定分配比特位
       int _c:10;
       int _d:30; 
       };
       ```

     + 位段是可以节省空间的
     + 冒号后面的数字是不可以超过实际大小的，也就是如果是int，那么最大也就是32可以放
     + 当开辟的比特位不够用时，才会开辟新的，且从开辟的新的地址放数据，也就是说，前面开辟的比特位可能会被浪费（分析的时候是这样，实际情况系统会直接计算出来，一次性开辟完）
     + 如果要放的数据大于分配的位数，就会发生截断，即高位可能会被省略

   * **位段的内存分配**

     + 位段的成员可以是int unsigned int signed int 或者是char （属于整形家族）类型

     + 位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的。

       + 一般位段里面放的是同一数据类型

       + 如果位段里面放的是int，那就是一次就要开辟四个字节，等这四个字节不够用了，

         再开辟四个字节，如果够用，一个数据放完就放下一个数据（实际是一次开辟完）

     + 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。

       ![image-20220715210154831](https://dawn1314.oss-cn-beijing.aliyuncs.com/202207152101887.png)

   + **位段的跨平台问题**

     + int 位段被当成有符号数还是无符号数是不确定的（在不同平台上）。
     2. 位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机
     器会出问题。
     3. 位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。
     + 当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的。
     4. 总结：
     跟结构相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题存在。
     + 光是在位段的时候，int是unsigned还是signed是无法确定的，但char是不在使用位段的时候还是在使用位段的时候都是不确定的。这个不确定是指，在一个平台是unsigned,跑到另一个平台可能就是signed的

   + 位段的应用

     ![image-20220715211655548](https://dawn1314.oss-cn-beijing.aliyuncs.com/202207152116629.png)

3. ==枚举==

   * **枚举的定义**

     + 以上定义的enum Day ， enum Sex ， enum Color 都是枚举类型。
       {}中的内容是枚举类型的可能取值，也叫枚举常量。
       这些可能取值都是有值的，默认从0开始，一次递增1，当然在定义的时候也可以赋初值。

     ```C
     enum Day//星期
     {
     Mon,   // 注意后面是逗号，不是分号
     Tues,
     Wed,
     Thur,
     Fri,
     Sat,
     Sun
     };
     enum Sex//性别
     {
     MALE,
     FEMALE,
     SECRET
     };
     
     ```

   * **枚举的使用**

     ![image-20220715214927740](https://dawn1314.oss-cn-beijing.aliyuncs.com/202207152149799.png)

     ```C
     enum Color//颜色
     {
     RED=1,
     GREEN=2,
     BLUE=4
     };
     // 上面只是模板，是不占内存的，只有下面创建变量时，才在内存占有空间
     
     // clr枚举类型，枚举类型的赋值是用枚举常量
     enum Color clr = GREEN;//只能拿枚举常量给枚举变量赋值，才不会出现类型的差异。
     clr = 5;
     ```

   * **枚举的优点**
     + 我们可以使用#define 定义常量，为什么非要使用枚举？
       枚举的优点：
       1. 增加代码的可读性和可维护性
       2. 和#define定义的标识符比较枚举有类型检查，更加严谨。
       3. 防止了命名污染（封装）
       4. 便于调试
          + ![image-20220715220648715](https://dawn1314.oss-cn-beijing.aliyuncs.com/202207152206773.png)
          + define定义的常量在预处理阶段，会把代码中的该常量全部调换成定义的数字或者字符之类，而枚举类型不会，在调试的时候还可以观察到·
       5. 使用方便，一次可以定义多个常量

   













































































































































































































